{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/index.js","webpack:///./node_modules/jStat/dist/jstat.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","jStat","require","window","S1","F1","S2","F2","startTime","Date","console","log","f","start","end","step","total","x1","x2","integrate","beta","pdf","timeDiff","checkErrors","vis","group","noun","count","min","max","addError","clearErrors","title","message","toLowerCase","looker","plugins","visualizations","add","id","label","options","skip_intermediate_nulls","section","type","order","default","element","config","$","append","attr","innerHTML","container","appendChild","document","createElement","className","this","_textElement","updateAsync","data","queryResponse","details","done","theData","theQuery","theOptions","self","res","fields","pivots","dimensions","measures","measure_like","length","min_pivots","max_pivots","min_dimensions","max_dimensions","min_measures","max_measures","HandleErrors","Math","undefined","concat","Array","slice","toString","calcRdx","val","pow","LOG10E","isArray","arg","isFunction","isNumber","_init","arguments","retZero","retOne","retIdent","j","fn","args","map","seq","apply","toArray","constructor","utils","toVector","arr","extend","obj","rows","cols","row","index","rowa","col","submat","arange","forEach","ind","column","cola","a","diag","nrow","antidiag","transpose","objArr","push","func","toAlter","ncol","cumreduce","alter","zeros","ones","rand","random","identity","symmetric","size","clear","cnt","hival","current","rl","_slice","list","copy","rcSlice","colSlice","rowSlice","sliceAssign","A","B","nl","ml","diagonal","diagArray","mat","jProto","sort","splice","funcs","passfunc","results","setTimeout","split","Function","ascNum","b","clip","sum","sumsqrd","sumsqerr","tmp","mean","sumrow","product","prod","low","high","unique","hash","_arr","meansqerr","geomean","median","arrlen","cumsum","cumprod","diff","diffs","arrLen","rank","sorted","ranks","first","indexOf","last","lastIndexOf","maxCount","numMaxCount","mode_arr","range","variance","flag","pooledvariance","reduce","samples","deviation","dev","stdev","sqrt","pooledstdev","meandev","abs","meddev","coeffvar","quartiles","round","quantiles","quantilesArray","alphap","betap","aleph","k","gamma","sortedArray","quantileVals","floor","percentile","realIndex","parseInt","frac","percentileOfScore","score","kind","counter","len","strict","histogram","bins","binCnt","binWidth","covariance","arr1","arr2","u","v","arr1Len","sq_dev","corrcoeff","spearmancoeff","stanMoment","mu","sigma","skewSum","skewness","kurtosis","fullbool","tmpthis","callbackFunction","argsToPass","curriedFunction","vector","gammaln","x","xx","y","cof","ser","gammafn","z","yi","q","fact","xden","xnum","Infinity","PI","sin","gammap","lowRegGamma","an","aln","ap","del","h","ITMAX","NaN","exp","factorialln","factorial","combination","combinationln","permutation","betafn","betaln","betacf","m2","aa","qab","qap","qam","gammapinv","pp","lna1","afac","a1","gln","erf","ty","isneg","dd","erfc","erfcinv","err","ibetainv","lna","lnb","al","w","b1","ibeta","bt","randn","randg","shape","a2","oalph","tukeyWprob","rr","cc","xleg","aleg","qsqz","wincr","pr_w","normal","cdf","blb","binc","bub","einsum","cc1","wi","elsum","jj","ac","qexpo","rinsum","callee","_a","_b","_c","newthis","sample","vals","fnfunc","alpha","inv","centralF","df1","df2","binomial","cauchy","local","scale","atan","tan","chisquare","dof","exponential","rate","invgamma","kumaraswamy","Error","lognormal","noncentralt","ncp","studentt","flip","prob","lastvalue","std","pareto","SQRT2","dof2","weibull","uniform","binomarr","negbin","hypgeom","N","scaledPDF","samplesDone","scaledCDF","factor","poisson","sumarr","L","triangular","arcsine","asin","cos","laplace","laplaceSign","tukey","nmeans","df","xlegq","alegq","Number","isFinite","ulen","f2","f2lf","f21","ff4","ans","otsum","twa1","t1","x0","ps","tukeyQinv","valx0","valx1","iter","isUsable","subtract","divide","multiply","nrescols","rescols","outer","dot","left","right","norm","nnorm","isNaN","angle","acos","aug","newarr","gauss_jordan","result","det","alen","alend","rowshift","colshift","mrow","mcol","gauss_elimination","maug","pivot","temp","maxrow","y2","triaUpSolve","parts","matrix_mode","triaLowSolve","lu","R","cholesky","T","gauss_jacobi","xv","xk","gauss_seidel","SOR","householder","QR","lstsq","array_mode","Q","attrs","Q1","RI","I","Aj","cAi","Ij","cIi","R_I","Q2","jacobi","maxim","theta","condition","e","ev","rungekutta","t_j","u_j","k1","k2","k3","romberg","h1","g","richardson","X","pos","y1","h_min","simpson","hermite","F","dF","dl","lagrange","cubic_spline","sq","gauss_quadrature","PCA","temp1","Bt","V","D","temp2","Y","C","Vt","differenceOfProportions","p1","n1","p2","n2","pooled","zscore","ztest","sides","tscore","ttest","anovafscore","expVar","sampMean","sampSampMean","tmpargs","unexpVar","anovaftest","ftest","fscore","anovaftes","qscore","mean1","mean2","sd","qtest","tukeyhsd","arrays","means","normalci","change","tci","significant","pvalue","oneSidedDifferenceOfProportions","twoSidedDifferenceOfProportions","models","ols","endog","exog","nobs","df_model","df_resid","coef","predict","resid","ybar","SSE","SSR","SST","R2","t_test","model","subModelList","var_count","endog_index","exog_index","filter","sub_regress","sigmaHat","seBetaHat","mod","tStatistic","pValue","leftppf","interval95","se","F_statistic","fcdf","F_test","adjust_R2","factory"],"mappings":"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","file":"main.fadd59945d78dec33678.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","// BEGIN Calculations specific to the A/B Testing Visualization\nconst jStat = require('jStat').jStat;\nwindow.jStat = jStat\n\nconst pdfOfAandB = function(x1, x2, S1, F1, S2, F2) {\n  return jStat.beta.pdf(x1, S1, F1) * jStat.beta.pdf(x2, S2, F2)\n}\nfunction integrate (f, start, end, step) {\n  let total = 0\n  step = step || 0.01\n  // Integrate over X2 > X1\n  for (let x1 = start; x1 < end; x1 += step) {\n    for (let x2 = x1; x2 < end; x2 += step) {\n      //total += f(x + step / 2) * step\n      total += f(x1 + step/2, x2 + step/2, S1, F1, S2, F2) * step * step\n    }\n  }\n  return total\n}\n\nconst S1 = 50000;\nconst F1 = 50000;\nconst S2 = 51000;\nconst F2 = 49000;\n\nlet startTime = new Date(); \nconsole.log(integrate(pdfOfAandB, 0, 1, 0.001))\nlet timeDiff = new Date() - startTime;\nconsole.log(timeDiff)\n// END Calculations specific to the A/B Testing Visualization\n\nvar lookerVisualizationOptions = {\n  skip_intermediate_nulls: {\n    section: \"Main\",\n    type: \"boolean\",\n    label: \"Skip intermediate nulls\",\n    order: 1,\n    default: false,\n  },\n  /*color_range: {\n    order: 4,\n    section: \"Colors\",\n    type: \"array\",\n    label: \"Color Range\",\n    display: \"colors\",\n    display_size: \"third\",\n  },\n  top_label: {\n    order: 3,\n    section: \"Colors\",\n    type: \"string\",\n    label: \"Label (for top)\",\n    placeholder: \"My Great Chart\",\n    display_size: \"third\",\n  },\n  test_1: {\n    order: 2,\n    section: \"Colors\",\n    type: \"number\",\n    display: \"range\",\n    label: \"Slide!!\",\n    display_size: \"third\",\n    min: 0,\n    max: 10,\n    step: 2,\n  },\n  boolean_option: {\n    section: \"Colors\",\n    type: \"boolean\",\n    label: \"Boolean option\",\n    order: 1\n  },\n  transport_mode: {\n    section: \"Modes\",\n    type: \"string\",\n    label: \"Mode of Transport\",\n    display: \"select\",\n    values: [\n       {\"Airplane\": \"airplane\"},\n       {\"Car\": \"car\"},\n       {\"Unicycle\": \"unicycle\"}\n    ],\n    default: \"unicycle\"\n  }*/\n}\n\nlooker.plugins.visualizations.add({\n  // Id and Label are legacy properties that no longer have any function besides documenting\n  // what the visualization used to have. The properties are now set via the manifest\n  // form within the admin/visualizations page of Looker\n  id: \"bayesian-ab-testing-results\",\n  label: \"Bayesian A/B Testing Results\",\n  options: lookerVisualizationOptions,\n  // Set up the initial state of the visualization\n  create: function(element, config) {\n    \n    $('head').append( $('<link rel=\"stylesheet\" type=\"text/css\" />').attr('href', 'https://localhost:4443/dependencies/global.css') );\n\n    // Insert a <style> tag with some styles we'll use later.\n    element.innerHTML = `\n      <style>\n        .hello-world-vis {\n          /* Vertical centering */\n          height: 100%;\n          display: flex;\n          flex-direction: column;\n          justify-content: center;\n          text-align: center;\n        }\n      </style>\n    `;\n\n    // Create a container element to let us center the text.\n    var container = element.appendChild(document.createElement(\"div\"));\n    container.className = \"hello-world-vis\";\n\n    // Create an element to contain the text.\n    this._textElement = container.appendChild(document.createElement(\"div\"));\n\n  },\n  // Render in response to the data or settings changing\n  updateAsync: function(data, element, config, queryResponse, details, done) {\n    \n    // Set some global variables to help with debugging\n    theData = data\n    theQuery = queryResponse\n    theOptions = config\n    self = this\n    this._textElement.id = \"canvas\";\n    \n    // Check for errors\n    var requirementsMet = HandleErrors(this, queryResponse, {\n      min_measures: 1, \n      max_measures: 1, \n      min_pivots: 0, \n      max_pivots: 0, \n      min_dimensions:1, \n      max_dimensions: 99,\n    })\n    if (!requirementsMet) return\n\n\n    // EXAMPLE: Register additional options\n    // newOptions = lookerVisualizationOptions\n    // queryResponse.fields.dimension_like.forEach(function(field) {\n    //   id = \"color_\" + field.name\n    //   newOptions[id] =\n    //     {\n    //       label: field.label_short + \" Color\",\n    //       default: \"#bbaabb\", // use selected palette for defaults\n    //       section: \"Style\",\n    //       type: \"string\",\n    //       display: \"color\"\n    //     }\n    // })\n    // this.trigger('registerOptions', newOptions) // register options with parent page to update visConfig\n    // END Example\n\n    // Grab the first cell of the data\n    // var firstRow = data[0];\n    // var firstCell = firstRow[queryResponse.fields.dimensions[0].name];\n    \n    // Insert the data into the page\n    // this._textElement.innerHTML = LookerCharts.Utils.htmlForCell(firstCell);\n\n    // Set the size to the user-selected size\n    /*\n    if (config.font_size == \"small\") {\n      this._textElement.className = \"hello-world-text-small\";\n    } else {\n      this._textElement.className = \"hello-world-text-large\";\n    }\n    */\n\n    // We are done rendering! Let Looker know.\n    done()\n  }\n});\n\n\n\nfunction HandleErrors(vis, res, options) {\n  var fields = res.fields\n  var pivots = fields.pivots\n  var dimensions = fields.dimensions\n  var measures = fields.measure_like\n  \n  return (checkErrors(vis, 'pivot-req', 'Pivot', pivots.length, options.min_pivots, options.max_pivots)\n      && checkErrors(vis, 'dim-req', 'Dimension', dimensions.length, options.min_dimensions, options.max_dimensions)\n      && checkErrors(vis, 'mes-req', 'Measure', measures.length, options.min_measures, options.max_measures))\n}\n\nfunction checkErrors(vis, group, noun, count, min, max) {\n  if (!vis.addError || !vis.clearErrors) return false\n  if (count < min) {\n      vis.addError({\n          title: `Not Enough ${noun}s`,\n          message: `This visualization requires ${min === max ? 'exactly' : 'at least'} ${min} ${noun.toLowerCase()}${ min === 1 ? '' : 's' }.`,\n          group\n      })\n      return false\n  }\n  if (count > max) {\n      vis.addError({\n          title: `Too Many ${noun}s`,\n          message: `This visualization requires ${min === max ? 'exactly' : 'no more than'} ${max} ${noun.toLowerCase()}${ min === 1 ? '' : 's' }.`,\n          group\n      })\n      return false\n  }\n  vis.clearErrors(group)\n  return true\n}\n\n","(function (window, factory) {\n    if (typeof exports === 'object') {\n        module.exports = factory();\n    } else if (typeof define === 'function' && define.amd) {\n        define(factory);\n    } else {\n        window.jStat = factory();\n    }\n})(this, function () {\nvar jStat = (function(Math, undefined) {\n\n// For quick reference.\nvar concat = Array.prototype.concat;\nvar slice = Array.prototype.slice;\nvar toString = Object.prototype.toString;\n\n// Calculate correction for IEEE error\n// TODO: This calculation can be improved.\nfunction calcRdx(n, m) {\n  var val = n > m ? n : m;\n  return Math.pow(10,\n                  17 - ~~(Math.log(((val > 0) ? val : -val)) * Math.LOG10E));\n}\n\n\nvar isArray = Array.isArray || function isArray(arg) {\n  return toString.call(arg) === '[object Array]';\n};\n\n\nfunction isFunction(arg) {\n  return toString.call(arg) === '[object Function]';\n}\n\n\nfunction isNumber(arg) {\n  return typeof arg === 'number' && arg === arg;\n}\n\n\n// Converts the jStat matrix to vector.\nfunction toVector(arr) {\n  return concat.apply([], arr);\n}\n\n\n// The one and only jStat constructor.\nfunction jStat() {\n  return new jStat._init(arguments);\n}\n\n\n// TODO: Remove after all references in src files have been removed.\njStat.fn = jStat.prototype;\n\n\n// By separating the initializer from the constructor it's easier to handle\n// always returning a new instance whether \"new\" was used or not.\njStat._init = function _init(args) {\n  var i;\n\n  // If first argument is an array, must be vector or matrix.\n  if (isArray(args[0])) {\n    // Check if matrix.\n    if (isArray(args[0][0])) {\n      // See if a mapping function was also passed.\n      if (isFunction(args[1]))\n        args[0] = jStat.map(args[0], args[1]);\n      // Iterate over each is faster than this.push.apply(this, args[0].\n      for (var i = 0; i < args[0].length; i++)\n        this[i] = args[0][i];\n      this.length = args[0].length;\n\n    // Otherwise must be a vector.\n    } else {\n      this[0] = isFunction(args[1]) ? jStat.map(args[0], args[1]) : args[0];\n      this.length = 1;\n    }\n\n  // If first argument is number, assume creation of sequence.\n  } else if (isNumber(args[0])) {\n    this[0] = jStat.seq.apply(null, args);\n    this.length = 1;\n\n  // Handle case when jStat object is passed to jStat.\n  } else if (args[0] instanceof jStat) {\n    // Duplicate the object and pass it back.\n    return jStat(args[0].toArray());\n\n  // Unexpected argument value, return empty jStat object.\n  // TODO: This is strange behavior. Shouldn't this throw or some such to let\n  // the user know they had bad arguments?\n  } else {\n    this[0] = [];\n    this.length = 1;\n  }\n\n  return this;\n};\njStat._init.prototype = jStat.prototype;\njStat._init.constructor = jStat;\n\n\n// Utility functions.\n// TODO: for internal use only?\njStat.utils = {\n  calcRdx: calcRdx,\n  isArray: isArray,\n  isFunction: isFunction,\n  isNumber: isNumber,\n  toVector: toVector\n};\n\n\n// Easily extend the jStat object.\n// TODO: is this seriously necessary?\njStat.extend = function extend(obj) {\n  var i, j;\n\n  if (arguments.length === 1) {\n    for (j in obj)\n      jStat[j] = obj[j];\n    return this;\n  }\n\n  for (var i = 1; i < arguments.length; i++) {\n    for (j in arguments[i])\n      obj[j] = arguments[i][j];\n  }\n\n  return obj;\n};\n\n\n// Returns the number of rows in the matrix.\njStat.rows = function rows(arr) {\n  return arr.length || 1;\n};\n\n\n// Returns the number of columns in the matrix.\njStat.cols = function cols(arr) {\n  return arr[0].length || 1;\n};\n\n\n// Returns the dimensions of the object { rows: i, cols: j }\njStat.dimensions = function dimensions(arr) {\n  return {\n    rows: jStat.rows(arr),\n    cols: jStat.cols(arr)\n  };\n};\n\n\n// Returns a specified row as a vector or return a sub matrix by pick some rows\njStat.row = function row(arr, index) {\n  if (isArray(index)) {\n    return index.map(function(i) {\n      return jStat.row(arr, i);\n    })\n  }\n  return arr[index];\n};\n\n\n// return row as array\n// rowa([[1,2],[3,4]],0) -> [1,2]\njStat.rowa = function rowa(arr, i) {\n  return jStat.row(arr, i);\n};\n\n\n// Returns the specified column as a vector or return a sub matrix by pick some\n// columns\njStat.col = function col(arr, index) {\n  if (isArray(index)) {\n    var submat = jStat.arange(arr.length).map(function(i) {\n      return new Array(index.length);\n    });\n    index.forEach(function(ind, i){\n      jStat.arange(arr.length).forEach(function(j) {\n        submat[j][i] = arr[j][ind];\n      });\n    });\n    return submat;\n  }\n  var column = new Array(arr.length);\n  for (var i = 0; i < arr.length; i++)\n    column[i] = [arr[i][index]];\n  return column;\n};\n\n\n// return column as array\n// cola([[1,2],[3,4]],0) -> [1,3]\njStat.cola = function cola(arr, i) {\n  return jStat.col(arr, i).map(function(a){ return a[0] });\n};\n\n\n// Returns the diagonal of the matrix\njStat.diag = function diag(arr) {\n  var nrow = jStat.rows(arr);\n  var res = new Array(nrow);\n  for (var row = 0; row < nrow; row++)\n    res[row] = [arr[row][row]];\n  return res;\n};\n\n\n// Returns the anti-diagonal of the matrix\njStat.antidiag = function antidiag(arr) {\n  var nrow = jStat.rows(arr) - 1;\n  var res = new Array(nrow);\n  for (var i = 0; nrow >= 0; nrow--, i++)\n    res[i] = [arr[i][nrow]];\n  return res;\n};\n\n// Transpose a matrix or array.\njStat.transpose = function transpose(arr) {\n  var obj = [];\n  var objArr, rows, cols, j, i;\n\n  // Make sure arr is in matrix format.\n  if (!isArray(arr[0]))\n    arr = [arr];\n\n  rows = arr.length;\n  cols = arr[0].length;\n\n  for (var i = 0; i < cols; i++) {\n    objArr = new Array(rows);\n    for (j = 0; j < rows; j++)\n      objArr[j] = arr[j][i];\n    obj.push(objArr);\n  }\n\n  // If obj is vector, return only single array.\n  return obj.length === 1 ? obj[0] : obj;\n};\n\n\n// Map a function to an array or array of arrays.\n// \"toAlter\" is an internal variable.\njStat.map = function map(arr, func, toAlter) {\n  var row, nrow, ncol, res, col;\n\n  if (!isArray(arr[0]))\n    arr = [arr];\n\n  nrow = arr.length;\n  ncol = arr[0].length;\n  res = toAlter ? arr : new Array(nrow);\n\n  for (row = 0; row < nrow; row++) {\n    // if the row doesn't exist, create it\n    if (!res[row])\n      res[row] = new Array(ncol);\n    for (col = 0; col < ncol; col++)\n      res[row][col] = func(arr[row][col], row, col);\n  }\n\n  return res.length === 1 ? res[0] : res;\n};\n\n\n// Cumulatively combine the elements of an array or array of arrays using a function.\njStat.cumreduce = function cumreduce(arr, func, toAlter) {\n  var row, nrow, ncol, res, col;\n\n  if (!isArray(arr[0]))\n    arr = [arr];\n\n  nrow = arr.length;\n  ncol = arr[0].length;\n  res = toAlter ? arr : new Array(nrow);\n\n  for (row = 0; row < nrow; row++) {\n    // if the row doesn't exist, create it\n    if (!res[row])\n      res[row] = new Array(ncol);\n    if (ncol > 0)\n      res[row][0] = arr[row][0];\n    for (col = 1; col < ncol; col++)\n      res[row][col] = func(res[row][col-1], arr[row][col]);\n  }\n  return res.length === 1 ? res[0] : res;\n};\n\n\n// Destructively alter an array.\njStat.alter = function alter(arr, func) {\n  return jStat.map(arr, func, true);\n};\n\n\n// Generate a rows x cols matrix according to the supplied function.\njStat.create = function  create(rows, cols, func) {\n  var res = new Array(rows);\n  var i, j;\n\n  if (isFunction(cols)) {\n    func = cols;\n    cols = rows;\n  }\n\n  for (var i = 0; i < rows; i++) {\n    res[i] = new Array(cols);\n    for (j = 0; j < cols; j++)\n      res[i][j] = func(i, j);\n  }\n\n  return res;\n};\n\n\nfunction retZero() { return 0; }\n\n\n// Generate a rows x cols matrix of zeros.\njStat.zeros = function zeros(rows, cols) {\n  if (!isNumber(cols))\n    cols = rows;\n  return jStat.create(rows, cols, retZero);\n};\n\n\nfunction retOne() { return 1; }\n\n\n// Generate a rows x cols matrix of ones.\njStat.ones = function ones(rows, cols) {\n  if (!isNumber(cols))\n    cols = rows;\n  return jStat.create(rows, cols, retOne);\n};\n\n\n// Generate a rows x cols matrix of uniformly random numbers.\njStat.rand = function rand(rows, cols) {\n  if (!isNumber(cols))\n    cols = rows;\n  return jStat.create(rows, cols, Math.random);\n};\n\n\nfunction retIdent(i, j) { return i === j ? 1 : 0; }\n\n\n// Generate an identity matrix of size row x cols.\njStat.identity = function identity(rows, cols) {\n  if (!isNumber(cols))\n    cols = rows;\n  return jStat.create(rows, cols, retIdent);\n};\n\n\n// Tests whether a matrix is symmetric\njStat.symmetric = function symmetric(arr) {\n  var issymmetric = true;\n  var size = arr.length;\n  var row, col;\n\n  if (arr.length !== arr[0].length)\n    return false;\n\n  for (row = 0; row < size; row++) {\n    for (col = 0; col < size; col++)\n      if (arr[col][row] !== arr[row][col])\n        return false;\n  }\n\n  return true;\n};\n\n\n// Set all values to zero.\njStat.clear = function clear(arr) {\n  return jStat.alter(arr, retZero);\n};\n\n\n// Generate sequence.\njStat.seq = function seq(min, max, length, func) {\n  if (!isFunction(func))\n    func = false;\n\n  var arr = [];\n  var hival = calcRdx(min, max);\n  var step = (max * hival - min * hival) / ((length - 1) * hival);\n  var current = min;\n  var cnt;\n\n  // Current is assigned using a technique to compensate for IEEE error.\n  // TODO: Needs better implementation.\n  for (cnt = 0;\n       current <= max && cnt < length;\n       cnt++, current = (min * hival + step * hival * cnt) / hival) {\n    arr.push((func ? func(current, cnt) : current));\n  }\n\n  return arr;\n};\n\n\n// arange(5) -> [0,1,2,3,4]\n// arange(1,5) -> [1,2,3,4]\n// arange(5,1,-1) -> [5,4,3,2]\njStat.arange = function arange(start, end, step) {\n  var rl = [];\n  step = step || 1;\n  if (end === undefined) {\n    end = start;\n    start = 0;\n  }\n  if (start === end || step === 0) {\n    return [];\n  }\n  if (start < end && step < 0) {\n    return [];\n  }\n  if (start > end && step > 0) {\n    return [];\n  }\n  if (step > 0) {\n    for (i = start; i < end; i += step) {\n      rl.push(i);\n    }\n  } else {\n    for (i = start; i > end; i += step) {\n      rl.push(i);\n    }\n  }\n  return rl;\n};\n\n\n// A=[[1,2,3],[4,5,6],[7,8,9]]\n// slice(A,{row:{end:2},col:{start:1}}) -> [[2,3],[5,6]]\n// slice(A,1,{start:1}) -> [5,6]\n// as numpy code A[:2,1:]\njStat.slice = (function(){\n  function _slice(list, start, end, step) {\n    // note it's not equal to range.map mode it's a bug\n    var i;\n    var rl = [];\n    var length = list.length;\n    if (start === undefined && end === undefined && step === undefined) {\n      return jStat.copy(list);\n    }\n\n    start = start || 0;\n    end = end || list.length;\n    start = start >= 0 ? start : length + start;\n    end = end >= 0 ? end : length + end;\n    step = step || 1;\n    if (start === end || step === 0) {\n      return [];\n    }\n    if (start < end && step < 0) {\n      return [];\n    }\n    if (start > end && step > 0) {\n      return [];\n    }\n    if (step > 0) {\n      for (i = start; i < end; i += step) {\n        rl.push(list[i]);\n      }\n    } else {\n      for (i = start; i > end;i += step) {\n        rl.push(list[i]);\n      }\n    }\n    return rl;\n  }\n\n  function slice(list, rcSlice) {\n    rcSlice = rcSlice || {};\n    if (isNumber(rcSlice.row)) {\n      if (isNumber(rcSlice.col))\n        return list[rcSlice.row][rcSlice.col];\n      var row = jStat.rowa(list, rcSlice.row);\n      var colSlice = rcSlice.col || {};\n      return _slice(row, colSlice.start, colSlice.end, colSlice.step);\n    }\n\n    if (isNumber(rcSlice.col)) {\n      var col = jStat.cola(list, rcSlice.col);\n      var rowSlice = rcSlice.row || {};\n      return _slice(col, rowSlice.start, rowSlice.end, rowSlice.step);\n    }\n\n    var rowSlice = rcSlice.row || {};\n    var colSlice = rcSlice.col || {};\n    var rows = _slice(list, rowSlice.start, rowSlice.end, rowSlice.step);\n    return rows.map(function(row) {\n      return _slice(row, colSlice.start, colSlice.end, colSlice.step);\n    });\n  }\n\n  return slice;\n}());\n\n\n// A=[[1,2,3],[4,5,6],[7,8,9]]\n// sliceAssign(A,{row:{start:1},col:{start:1}},[[0,0],[0,0]])\n// A=[[1,2,3],[4,0,0],[7,0,0]]\njStat.sliceAssign = function sliceAssign(A, rcSlice, B) {\n  if (isNumber(rcSlice.row)) {\n    if (isNumber(rcSlice.col))\n      return A[rcSlice.row][rcSlice.col] = B;\n    rcSlice.col = rcSlice.col || {};\n    rcSlice.col.start = rcSlice.col.start || 0;\n    rcSlice.col.end = rcSlice.col.end || A[0].length;\n    rcSlice.col.step = rcSlice.col.step || 1;\n    var nl = jStat.arange(rcSlice.col.start,\n                          Math.min(A.length, rcSlice.col.end),\n                          rcSlice.col.step);\n    var m = rcSlice.row;\n    nl.forEach(function(n, i) {\n      A[m][n] = B[i];\n    });\n    return A;\n  }\n\n  if (isNumber(rcSlice.col)) {\n    rcSlice.row = rcSlice.row || {};\n    rcSlice.row.start = rcSlice.row.start || 0;\n    rcSlice.row.end = rcSlice.row.end || A.length;\n    rcSlice.row.step = rcSlice.row.step || 1;\n    var ml = jStat.arange(rcSlice.row.start,\n                          Math.min(A[0].length, rcSlice.row.end),\n                          rcSlice.row.step);\n    var n = rcSlice.col;\n    ml.forEach(function(m, j) {\n      A[m][n] = B[j];\n    });\n    return A;\n  }\n\n  if (B[0].length === undefined) {\n    B = [B];\n  }\n  rcSlice.row.start = rcSlice.row.start || 0;\n  rcSlice.row.end = rcSlice.row.end || A.length;\n  rcSlice.row.step = rcSlice.row.step || 1;\n  rcSlice.col.start = rcSlice.col.start || 0;\n  rcSlice.col.end = rcSlice.col.end || A[0].length;\n  rcSlice.col.step = rcSlice.col.step || 1;\n  var ml = jStat.arange(rcSlice.row.start,\n                        Math.min(A.length, rcSlice.row.end),\n                        rcSlice.row.step);\n  var nl = jStat.arange(rcSlice.col.start,\n                        Math.min(A[0].length, rcSlice.col.end),\n                        rcSlice.col.step);\n  ml.forEach(function(m, i) {\n    nl.forEach(function(n, j) {\n      A[m][n] = B[i][j];\n    });\n  });\n  return A;\n};\n\n\n// [1,2,3] ->\n// [[1,0,0],[0,2,0],[0,0,3]]\njStat.diagonal = function diagonal(diagArray) {\n  var mat = jStat.zeros(diagArray.length, diagArray.length);\n  diagArray.forEach(function(t, i) {\n    mat[i][i] = t;\n  });\n  return mat;\n};\n\n\n// return copy of A\njStat.copy = function copy(A) {\n  return A.map(function(row) {\n    if (isNumber(row))\n      return row;\n    return row.map(function(t) {\n      return t;\n    });\n  });\n};\n\n\n// TODO: Go over this entire implementation. Seems a tragic waste of resources\n// doing all this work. Instead, and while ugly, use new Function() to generate\n// a custom function for each static method.\n\n// Quick reference.\nvar jProto = jStat.prototype;\n\n// Default length.\njProto.length = 0;\n\n// For internal use only.\n// TODO: Check if they're actually used, and if they are then rename them\n// to _*\njProto.push = Array.prototype.push;\njProto.sort = Array.prototype.sort;\njProto.splice = Array.prototype.splice;\njProto.slice = Array.prototype.slice;\n\n\n// Return a clean array.\njProto.toArray = function toArray() {\n  return this.length > 1 ? slice.call(this) : slice.call(this)[0];\n};\n\n\n// Map a function to a matrix or vector.\njProto.map = function map(func, toAlter) {\n  return jStat(jStat.map(this, func, toAlter));\n};\n\n\n// Cumulatively combine the elements of a matrix or vector using a function.\njProto.cumreduce = function cumreduce(func, toAlter) {\n  return jStat(jStat.cumreduce(this, func, toAlter));\n};\n\n\n// Destructively alter an array.\njProto.alter = function alter(func) {\n  jStat.alter(this, func);\n  return this;\n};\n\n\n// Extend prototype with methods that have no argument.\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    jProto[passfunc] = function(func) {\n      var self = this,\n      results;\n      // Check for callback.\n      if (func) {\n        setTimeout(function() {\n          func.call(self, jProto[passfunc].call(self));\n        });\n        return this;\n      }\n      results = jStat[passfunc](this);\n      return isArray(results) ? jStat(results) : results;\n    };\n  })(funcs[i]);\n})('transpose clear symmetric rows cols dimensions diag antidiag'.split(' '));\n\n\n// Extend prototype with methods that have one argument.\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    jProto[passfunc] = function(index, func) {\n      var self = this;\n      // check for callback\n      if (func) {\n        setTimeout(function() {\n          func.call(self, jProto[passfunc].call(self, index));\n        });\n        return this;\n      }\n      return jStat(jStat[passfunc](this, index));\n    };\n  })(funcs[i]);\n})('row col'.split(' '));\n\n\n// Extend prototype with simple shortcut methods.\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    jProto[passfunc] = new Function(\n        'return jStat(jStat.' + passfunc + '.apply(null, arguments));');\n  })(funcs[i]);\n})('create zeros ones rand identity'.split(' '));\n\n\n// Exposing jStat.\nreturn jStat;\n\n}(Math));\n(function(jStat, Math) {\n\nvar isFunction = jStat.utils.isFunction;\n\n// Ascending functions for sort\nfunction ascNum(a, b) { return a - b; }\n\nfunction clip(arg, min, max) {\n  return Math.max(min, Math.min(arg, max));\n}\n\n\n// sum of an array\njStat.sum = function sum(arr) {\n  var sum = 0;\n  var i = arr.length;\n  while (--i >= 0)\n    sum += arr[i];\n  return sum;\n};\n\n\n// sum squared\njStat.sumsqrd = function sumsqrd(arr) {\n  var sum = 0;\n  var i = arr.length;\n  while (--i >= 0)\n    sum += arr[i] * arr[i];\n  return sum;\n};\n\n\n// sum of squared errors of prediction (SSE)\njStat.sumsqerr = function sumsqerr(arr) {\n  var mean = jStat.mean(arr);\n  var sum = 0;\n  var i = arr.length;\n  var tmp;\n  while (--i >= 0) {\n    tmp = arr[i] - mean;\n    sum += tmp * tmp;\n  }\n  return sum;\n};\n\n// sum of an array in each row\njStat.sumrow = function sumrow(arr) {\n  var sum = 0;\n  var i = arr.length;\n  while (--i >= 0)\n    sum += arr[i];\n  return sum;\n};\n\n// product of an array\njStat.product = function product(arr) {\n  var prod = 1;\n  var i = arr.length;\n  while (--i >= 0)\n    prod *= arr[i];\n  return prod;\n};\n\n\n// minimum value of an array\njStat.min = function min(arr) {\n  var low = arr[0];\n  var i = 0;\n  while (++i < arr.length)\n    if (arr[i] < low)\n      low = arr[i];\n  return low;\n};\n\n\n// maximum value of an array\njStat.max = function max(arr) {\n  var high = arr[0];\n  var i = 0;\n  while (++i < arr.length)\n    if (arr[i] > high)\n      high = arr[i];\n  return high;\n};\n\n\n// unique values of an array\njStat.unique = function unique(arr) {\n  var hash = {}, _arr = [];\n  for(var i = 0; i < arr.length; i++) {\n    if (!hash[arr[i]]) {\n      hash[arr[i]] = true;\n      _arr.push(arr[i]);\n    }\n  }\n  return _arr;\n};\n\n\n// mean value of an array\njStat.mean = function mean(arr) {\n  return jStat.sum(arr) / arr.length;\n};\n\n\n// mean squared error (MSE)\njStat.meansqerr = function meansqerr(arr) {\n  return jStat.sumsqerr(arr) / arr.length;\n};\n\n\n// geometric mean of an array\njStat.geomean = function geomean(arr) {\n  return Math.pow(jStat.product(arr), 1 / arr.length);\n};\n\n\n// median of an array\njStat.median = function median(arr) {\n  var arrlen = arr.length;\n  var _arr = arr.slice().sort(ascNum);\n  // check if array is even or odd, then return the appropriate\n  return !(arrlen & 1)\n    ? (_arr[(arrlen / 2) - 1 ] + _arr[(arrlen / 2)]) / 2\n    : _arr[(arrlen / 2) | 0 ];\n};\n\n\n// cumulative sum of an array\njStat.cumsum = function cumsum(arr) {\n  return jStat.cumreduce(arr, function (a, b) { return a + b; });\n};\n\n\n// cumulative product of an array\njStat.cumprod = function cumprod(arr) {\n  return jStat.cumreduce(arr, function (a, b) { return a * b; });\n};\n\n\n// successive differences of a sequence\njStat.diff = function diff(arr) {\n  var diffs = [];\n  var arrLen = arr.length;\n  var i;\n  for (var i = 1; i < arrLen; i++)\n    diffs.push(arr[i] - arr[i - 1]);\n  return diffs;\n};\n\n\n// ranks of an array\njStat.rank = function (arr) {\n  var arrlen = arr.length;\n  var sorted = arr.slice().sort(ascNum);\n  var ranks = new Array(arrlen);\n  for (var i = 0; i < arrlen; i++) {\n    var first = sorted.indexOf(arr[i]);\n    var last = sorted.lastIndexOf(arr[i]);\n    if (first === last) {\n      var val = first;\n    } else {\n      var val = (first + last) / 2;\n    }\n    ranks[i] = val + 1;\n  }\n  return ranks;\n};\n\n\n// mode of an array\n// if there are multiple modes of an array, return all of them\n// is this the appropriate way of handling it?\njStat.mode = function mode(arr) {\n  var arrLen = arr.length;\n  var _arr = arr.slice().sort(ascNum);\n  var count = 1;\n  var maxCount = 0;\n  var numMaxCount = 0;\n  var mode_arr = [];\n  var i;\n\n  for (var i = 0; i < arrLen; i++) {\n    if (_arr[i] === _arr[i + 1]) {\n      count++;\n    } else {\n      if (count > maxCount) {\n        mode_arr = [_arr[i]];\n        maxCount = count;\n        numMaxCount = 0;\n      }\n      // are there multiple max counts\n      else if (count === maxCount) {\n        mode_arr.push(_arr[i]);\n        numMaxCount++;\n      }\n      // resetting count for new value in array\n      count = 1;\n    }\n  }\n\n  return numMaxCount === 0 ? mode_arr[0] : mode_arr;\n};\n\n\n// range of an array\njStat.range = function range(arr) {\n  return jStat.max(arr) - jStat.min(arr);\n};\n\n// variance of an array\n// flag = true indicates sample instead of population\njStat.variance = function variance(arr, flag) {\n  return jStat.sumsqerr(arr) / (arr.length - (flag ? 1 : 0));\n};\n\n// pooled variance of an array of arrays\njStat.pooledvariance = function pooledvariance(arr) {\n  var sumsqerr = arr.reduce(function (a, samples) {return a + jStat.sumsqerr(samples);}, 0);\n  var count = arr.reduce(function (a, samples) {return a + samples.length;}, 0);\n  return sumsqerr / (count - arr.length);\n};\n\n// deviation of an array\njStat.deviation = function (arr) {\n  var mean = jStat.mean(arr);\n  var arrlen = arr.length;\n  var dev = new Array(arrlen);\n  for (var i = 0; i < arrlen; i++) {\n    dev[i] = arr[i] - mean;\n  }\n  return dev;\n};\n\n// standard deviation of an array\n// flag = true indicates sample instead of population\njStat.stdev = function stdev(arr, flag) {\n  return Math.sqrt(jStat.variance(arr, flag));\n};\n\n// pooled standard deviation of an array of arrays\njStat.pooledstdev = function pooledstdev(arr) {\n  return Math.sqrt(jStat.pooledvariance(arr));\n};\n\n// mean deviation (mean absolute deviation) of an array\njStat.meandev = function meandev(arr) {\n  var mean = jStat.mean(arr);\n  var a = [];\n  for (var i = arr.length - 1; i >= 0; i--) {\n    a.push(Math.abs(arr[i] - mean));\n  }\n  return jStat.mean(a);\n};\n\n\n// median deviation (median absolute deviation) of an array\njStat.meddev = function meddev(arr) {\n  var median = jStat.median(arr);\n  var a = [];\n  for (var i = arr.length - 1; i >= 0; i--) {\n    a.push(Math.abs(arr[i] - median));\n  }\n  return jStat.median(a);\n};\n\n\n// coefficient of variation\njStat.coeffvar = function coeffvar(arr) {\n  return jStat.stdev(arr) / jStat.mean(arr);\n};\n\n\n// quartiles of an array\njStat.quartiles = function quartiles(arr) {\n  var arrlen = arr.length;\n  var _arr = arr.slice().sort(ascNum);\n  return [\n    _arr[ Math.round((arrlen) / 4) - 1 ],\n    _arr[ Math.round((arrlen) / 2) - 1 ],\n    _arr[ Math.round((arrlen) * 3 / 4) - 1 ]\n  ];\n};\n\n\n// Arbitary quantiles of an array. Direct port of the scipy.stats\n// implementation by Pierre GF Gerard-Marchant.\njStat.quantiles = function quantiles(arr, quantilesArray, alphap, betap) {\n  var sortedArray = arr.slice().sort(ascNum);\n  var quantileVals = [quantilesArray.length];\n  var n = arr.length;\n  var i, p, m, aleph, k, gamma;\n\n  if (typeof alphap === 'undefined')\n    alphap = 3 / 8;\n  if (typeof betap === 'undefined')\n    betap = 3 / 8;\n\n  for (var i = 0; i < quantilesArray.length; i++) {\n    p = quantilesArray[i];\n    m = alphap + p * (1 - alphap - betap);\n    aleph = n * p + m;\n    k = Math.floor(clip(aleph, 1, n - 1));\n    gamma = clip(aleph - k, 0, 1);\n    quantileVals[i] = (1 - gamma) * sortedArray[k - 1] + gamma * sortedArray[k];\n  }\n\n  return quantileVals;\n};\n\n// Returns the k-th percentile of values in a range, where k is in the\n// range 0..1, exclusive.\njStat.percentile = function percentile(arr, k) {\n  var _arr = arr.slice().sort(ascNum);\n  var realIndex = k * (_arr.length - 1);\n  var index = parseInt(realIndex);\n  var frac = realIndex - index;\n\n  if (index + 1 < _arr.length) {\n    return _arr[index] * (1 - frac) + _arr[index + 1] * frac;\n  } else {\n    return _arr[index];\n  }\n}\n\n\n// The percentile rank of score in a given array. Returns the percentage\n// of all values in the input array that are less than (kind='strict') or\n// less or equal than (kind='weak') score. Default is weak.\njStat.percentileOfScore = function percentileOfScore(arr, score, kind) {\n  var counter = 0;\n  var len = arr.length;\n  var strict = false;\n  var value, i;\n\n  if (kind === 'strict')\n    strict = true;\n\n  for (var i = 0; i < len; i++) {\n    value = arr[i];\n    if ((strict && value < score) ||\n        (!strict && value <= score)) {\n      counter++;\n    }\n  }\n\n  return counter / len;\n};\n\n\n// Histogram (bin count) data\njStat.histogram = function histogram(arr, bins) {\n  var first = jStat.min(arr);\n  var binCnt = bins || 4;\n  var binWidth = (jStat.max(arr) - first) / binCnt;\n  var len = arr.length;\n  var bins = [];\n  var i;\n\n  for (var i = 0; i < binCnt; i++)\n    bins[i] = 0;\n  for (var i = 0; i < len; i++)\n    bins[Math.min(Math.floor(((arr[i] - first) / binWidth)), binCnt - 1)] += 1;\n\n  return bins;\n};\n\n\n// covariance of two arrays\njStat.covariance = function covariance(arr1, arr2) {\n  var u = jStat.mean(arr1);\n  var v = jStat.mean(arr2);\n  var arr1Len = arr1.length;\n  var sq_dev = new Array(arr1Len);\n  var i;\n\n  for (var i = 0; i < arr1Len; i++)\n    sq_dev[i] = (arr1[i] - u) * (arr2[i] - v);\n\n  return jStat.sum(sq_dev) / (arr1Len - 1);\n};\n\n\n// (pearson's) population correlation coefficient, rho\njStat.corrcoeff = function corrcoeff(arr1, arr2) {\n  return jStat.covariance(arr1, arr2) /\n      jStat.stdev(arr1, 1) /\n      jStat.stdev(arr2, 1);\n};\n\n  // (spearman's) rank correlation coefficient, sp\njStat.spearmancoeff =  function (arr1, arr2) {\n  arr1 = jStat.rank(arr1);\n  arr2 = jStat.rank(arr2);\n  //return pearson's correlation of the ranks:\n  return jStat.corrcoeff(arr1, arr2);\n}\n\n\n// statistical standardized moments (general form of skew/kurt)\njStat.stanMoment = function stanMoment(arr, n) {\n  var mu = jStat.mean(arr);\n  var sigma = jStat.stdev(arr);\n  var len = arr.length;\n  var skewSum = 0;\n\n  for (var i = 0; i < len; i++)\n    skewSum += Math.pow((arr[i] - mu) / sigma, n);\n\n  return skewSum / arr.length;\n};\n\n// (pearson's) moment coefficient of skewness\njStat.skewness = function skewness(arr) {\n  return jStat.stanMoment(arr, 3);\n};\n\n// (pearson's) (excess) kurtosis\njStat.kurtosis = function kurtosis(arr) {\n  return jStat.stanMoment(arr, 4) - 3;\n};\n\n\nvar jProto = jStat.prototype;\n\n\n// Extend jProto with method for calculating cumulative sums and products.\n// This differs from the similar extension below as cumsum and cumprod should\n// not be run again in the case fullbool === true.\n// If a matrix is passed, automatically assume operation should be done on the\n// columns.\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    // If a matrix is passed, automatically assume operation should be done on\n    // the columns.\n    jProto[passfunc] = function(fullbool, func) {\n      var arr = [];\n      var i = 0;\n      var tmpthis = this;\n      // Assignment reassignation depending on how parameters were passed in.\n      if (isFunction(fullbool)) {\n        func = fullbool;\n        fullbool = false;\n      }\n      // Check if a callback was passed with the function.\n      if (func) {\n        setTimeout(function() {\n          func.call(tmpthis, jProto[passfunc].call(tmpthis, fullbool));\n        });\n        return this;\n      }\n      // Check if matrix and run calculations.\n      if (this.length > 1) {\n        tmpthis = fullbool === true ? this : this.transpose();\n        for (; i < tmpthis.length; i++)\n          arr[i] = jStat[passfunc](tmpthis[i]);\n        return arr;\n      }\n      // Pass fullbool if only vector, not a matrix. for variance and stdev.\n      return jStat[passfunc](this[0], fullbool);\n    };\n  })(funcs[i]);\n})(('cumsum cumprod').split(' '));\n\n\n// Extend jProto with methods which don't require arguments and work on columns.\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    // If a matrix is passed, automatically assume operation should be done on\n    // the columns.\n    jProto[passfunc] = function(fullbool, func) {\n      var arr = [];\n      var i = 0;\n      var tmpthis = this;\n      // Assignment reassignation depending on how parameters were passed in.\n      if (isFunction(fullbool)) {\n        func = fullbool;\n        fullbool = false;\n      }\n      // Check if a callback was passed with the function.\n      if (func) {\n        setTimeout(function() {\n          func.call(tmpthis, jProto[passfunc].call(tmpthis, fullbool));\n        });\n        return this;\n      }\n      // Check if matrix and run calculations.\n      if (this.length > 1) {\n        if (passfunc !== 'sumrow')\n          tmpthis = fullbool === true ? this : this.transpose();\n        for (; i < tmpthis.length; i++)\n          arr[i] = jStat[passfunc](tmpthis[i]);\n        return fullbool === true\n            ? jStat[passfunc](jStat.utils.toVector(arr))\n            : arr;\n      }\n      // Pass fullbool if only vector, not a matrix. for variance and stdev.\n      return jStat[passfunc](this[0], fullbool);\n    };\n  })(funcs[i]);\n})(('sum sumsqrd sumsqerr sumrow product min max unique mean meansqerr ' +\n    'geomean median diff rank mode range variance deviation stdev meandev ' +\n    'meddev coeffvar quartiles histogram skewness kurtosis').split(' '));\n\n\n// Extend jProto with functions that take arguments. Operations on matrices are\n// done on columns.\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    jProto[passfunc] = function() {\n      var arr = [];\n      var i = 0;\n      var tmpthis = this;\n      var args = Array.prototype.slice.call(arguments);\n\n      // If the last argument is a function, we assume it's a callback; we\n      // strip the callback out and call the function again.\n      if (isFunction(args[args.length - 1])) {\n        var callbackFunction = args[args.length - 1];\n        var argsToPass = args.slice(0, args.length - 1);\n\n        setTimeout(function() {\n          callbackFunction.call(tmpthis,\n                                jProto[passfunc].apply(tmpthis, argsToPass));\n        });\n        return this;\n\n      // Otherwise we curry the function args and call normally.\n      } else {\n        var callbackFunction = undefined;\n        var curriedFunction = function curriedFunction(vector) {\n          return jStat[passfunc].apply(tmpthis, [vector].concat(args));\n        }\n      }\n\n      // If this is a matrix, run column-by-column.\n      if (this.length > 1) {\n        tmpthis = tmpthis.transpose();\n        for (; i < tmpthis.length; i++)\n          arr[i] = curriedFunction(tmpthis[i]);\n        return arr;\n      }\n\n      // Otherwise run on the vector.\n      return curriedFunction(this[0]);\n    };\n  })(funcs[i]);\n})('quantiles percentileOfScore'.split(' '));\n\n}(jStat, Math));\n// Special functions //\n(function(jStat, Math) {\n\n// Log-gamma function\njStat.gammaln = function gammaln(x) {\n  var j = 0;\n  var cof = [\n    76.18009172947146, -86.50532032941677, 24.01409824083091,\n    -1.231739572450155, 0.1208650973866179e-2, -0.5395239384953e-5\n  ];\n  var ser = 1.000000000190015;\n  var xx, y, tmp;\n  tmp = (y = xx = x) + 5.5;\n  tmp -= (xx + 0.5) * Math.log(tmp);\n  for (; j < 6; j++)\n    ser += cof[j] / ++y;\n  return Math.log(2.5066282746310005 * ser / xx) - tmp;\n};\n\n\n// gamma of x\njStat.gammafn = function gammafn(x) {\n  var p = [-1.716185138865495, 24.76565080557592, -379.80425647094563,\n           629.3311553128184, 866.9662027904133, -31451.272968848367,\n           -36144.413418691176, 66456.14382024054\n  ];\n  var q = [-30.8402300119739, 315.35062697960416, -1015.1563674902192,\n           -3107.771671572311, 22538.118420980151, 4755.8462775278811,\n           -134659.9598649693, -115132.2596755535];\n  var fact = false;\n  var n = 0;\n  var xden = 0;\n  var xnum = 0;\n  var y = x;\n  var i, z, yi, res, sum, ysq;\n  if (y <= 0) {\n    res = y % 1 + 3.6e-16;\n    if (res) {\n      fact = (!(y & 1) ? 1 : -1) * Math.PI / Math.sin(Math.PI * res);\n      y = 1 - y;\n    } else {\n      return Infinity;\n    }\n  }\n  yi = y;\n  if (y < 1) {\n    z = y++;\n  } else {\n    z = (y -= n = (y | 0) - 1) - 1;\n  }\n  for (var i = 0; i < 8; ++i) {\n    xnum = (xnum + p[i]) * z;\n    xden = xden * z + q[i];\n  }\n  res = xnum / xden + 1;\n  if (yi < y) {\n    res /= yi;\n  } else if (yi > y) {\n    for (var i = 0; i < n; ++i) {\n      res *= y;\n      y++;\n    }\n  }\n  if (fact) {\n    res = fact / res;\n  }\n  return res;\n};\n\n\n// lower incomplete gamma function, which is usually typeset with a\n// lower-case greek gamma as the function symbol\njStat.gammap = function gammap(a, x) {\n  return jStat.lowRegGamma(a, x) * jStat.gammafn(a);\n};\n\n\n// The lower regularized incomplete gamma function, usually written P(a,x)\njStat.lowRegGamma = function lowRegGamma(a, x) {\n  var aln = jStat.gammaln(a);\n  var ap = a;\n  var sum = 1 / a;\n  var del = sum;\n  var b = x + 1 - a;\n  var c = 1 / 1.0e-30;\n  var d = 1 / b;\n  var h = d;\n  var i = 1;\n  // calculate maximum number of itterations required for a\n  var ITMAX = -~(Math.log((a >= 1) ? a : 1 / a) * 8.5 + a * 0.4 + 17);\n  var an, endval;\n\n  if (x < 0 || a <= 0) {\n    return NaN;\n  } else if (x < a + 1) {\n    for (; i <= ITMAX; i++) {\n      sum += del *= x / ++ap;\n    }\n    return (sum * Math.exp(-x + a * Math.log(x) - (aln)));\n  }\n\n  for (; i <= ITMAX; i++) {\n    an = -i * (i - a);\n    b += 2;\n    d = an * d + b;\n    c = b + an / c;\n    d = 1 / d;\n    h *= d * c;\n  }\n\n  return (1 - h * Math.exp(-x + a * Math.log(x) - (aln)));\n};\n\n// natural log factorial of n\njStat.factorialln = function factorialln(n) {\n  return n < 0 ? NaN : jStat.gammaln(n + 1);\n};\n\n// factorial of n\njStat.factorial = function factorial(n) {\n  return n < 0 ? NaN : jStat.gammafn(n + 1);\n};\n\n// combinations of n, m\njStat.combination = function combination(n, m) {\n  // make sure n or m don't exceed the upper limit of usable values\n  return (n > 170 || m > 170)\n      ? Math.exp(jStat.combinationln(n, m))\n      : (jStat.factorial(n) / jStat.factorial(m)) / jStat.factorial(n - m);\n};\n\n\njStat.combinationln = function combinationln(n, m){\n  return jStat.factorialln(n) - jStat.factorialln(m) - jStat.factorialln(n - m);\n};\n\n\n// permutations of n, m\njStat.permutation = function permutation(n, m) {\n  return jStat.factorial(n) / jStat.factorial(n - m);\n};\n\n\n// beta function\njStat.betafn = function betafn(x, y) {\n  // ensure arguments are positive\n  if (x <= 0 || y <= 0)\n    return undefined;\n  // make sure x + y doesn't exceed the upper limit of usable values\n  return (x + y > 170)\n      ? Math.exp(jStat.betaln(x, y))\n      : jStat.gammafn(x) * jStat.gammafn(y) / jStat.gammafn(x + y);\n};\n\n\n// natural logarithm of beta function\njStat.betaln = function betaln(x, y) {\n  return jStat.gammaln(x) + jStat.gammaln(y) - jStat.gammaln(x + y);\n};\n\n\n// Evaluates the continued fraction for incomplete beta function by modified\n// Lentz's method.\njStat.betacf = function betacf(x, a, b) {\n  var fpmin = 1e-30;\n  var m = 1;\n  var qab = a + b;\n  var qap = a + 1;\n  var qam = a - 1;\n  var c = 1;\n  var d = 1 - qab * x / qap;\n  var m2, aa, del, h;\n\n  // These q's will be used in factors that occur in the coefficients\n  if (Math.abs(d) < fpmin)\n    d = fpmin;\n  d = 1 / d;\n  h = d;\n\n  for (; m <= 100; m++) {\n    m2 = 2 * m;\n    aa = m * (b - m) * x / ((qam + m2) * (a + m2));\n    // One step (the even one) of the recurrence\n    d = 1 + aa * d;\n    if (Math.abs(d) < fpmin)\n      d = fpmin;\n    c = 1 + aa / c;\n    if (Math.abs(c) < fpmin)\n      c = fpmin;\n    d = 1 / d;\n    h *= d * c;\n    aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));\n    // Next step of the recurrence (the odd one)\n    d = 1 + aa * d;\n    if (Math.abs(d) < fpmin)\n      d = fpmin;\n    c = 1 + aa / c;\n    if (Math.abs(c) < fpmin)\n      c = fpmin;\n    d = 1 / d;\n    del = d * c;\n    h *= del;\n    if (Math.abs(del - 1.0) < 3e-7)\n      break;\n  }\n\n  return h;\n};\n\n\n// Returns the inverse of the lower regularized inomplete gamma function\njStat.gammapinv = function gammapinv(p, a) {\n  var j = 0;\n  var a1 = a - 1;\n  var EPS = 1e-8;\n  var gln = jStat.gammaln(a);\n  var x, err, t, u, pp, lna1, afac;\n\n  if (p >= 1)\n    return Math.max(100, a + 100 * Math.sqrt(a));\n  if (p <= 0)\n    return 0;\n  if (a > 1) {\n    lna1 = Math.log(a1);\n    afac = Math.exp(a1 * (lna1 - 1) - gln);\n    pp = (p < 0.5) ? p : 1 - p;\n    t = Math.sqrt(-2 * Math.log(pp));\n    x = (2.30753 + t * 0.27061) / (1 + t * (0.99229 + t * 0.04481)) - t;\n    if (p < 0.5)\n      x = -x;\n    x = Math.max(1e-3,\n                 a * Math.pow(1 - 1 / (9 * a) - x / (3 * Math.sqrt(a)), 3));\n  } else {\n    t = 1 - a * (0.253 + a * 0.12);\n    if (p < t)\n      x = Math.pow(p / t, 1 / a);\n    else\n      x = 1 - Math.log(1 - (p - t) / (1 - t));\n  }\n\n  for(; j < 12; j++) {\n    if (x <= 0)\n      return 0;\n    err = jStat.lowRegGamma(a, x) - p;\n    if (a > 1)\n      t = afac * Math.exp(-(x - a1) + a1 * (Math.log(x) - lna1));\n    else\n      t = Math.exp(-x + a1 * Math.log(x) - gln);\n    u = err / t;\n    x -= (t = u / (1 - 0.5 * Math.min(1, u * ((a - 1) / x - 1))));\n    if (x <= 0)\n      x = 0.5 * (x + t);\n    if (Math.abs(t) < EPS * x)\n      break;\n  }\n\n  return x;\n};\n\n\n// Returns the error function erf(x)\njStat.erf = function erf(x) {\n  var cof = [-1.3026537197817094, 6.4196979235649026e-1, 1.9476473204185836e-2,\n             -9.561514786808631e-3, -9.46595344482036e-4, 3.66839497852761e-4,\n             4.2523324806907e-5, -2.0278578112534e-5, -1.624290004647e-6,\n             1.303655835580e-6, 1.5626441722e-8, -8.5238095915e-8,\n             6.529054439e-9, 5.059343495e-9, -9.91364156e-10,\n             -2.27365122e-10, 9.6467911e-11, 2.394038e-12,\n             -6.886027e-12, 8.94487e-13, 3.13092e-13,\n             -1.12708e-13, 3.81e-16, 7.106e-15,\n             -1.523e-15, -9.4e-17, 1.21e-16,\n             -2.8e-17];\n  var j = cof.length - 1;\n  var isneg = false;\n  var d = 0;\n  var dd = 0;\n  var t, ty, tmp, res;\n\n  if (x < 0) {\n    x = -x;\n    isneg = true;\n  }\n\n  t = 2 / (2 + x);\n  ty = 4 * t - 2;\n\n  for(; j > 0; j--) {\n    tmp = d;\n    d = ty * d - dd + cof[j];\n    dd = tmp;\n  }\n\n  res = t * Math.exp(-x * x + 0.5 * (cof[0] + ty * d) - dd);\n  return isneg ? res - 1 : 1 - res;\n};\n\n\n// Returns the complmentary error function erfc(x)\njStat.erfc = function erfc(x) {\n  return 1 - jStat.erf(x);\n};\n\n\n// Returns the inverse of the complementary error function\njStat.erfcinv = function erfcinv(p) {\n  var j = 0;\n  var x, err, t, pp;\n  if (p >= 2)\n    return -100;\n  if (p <= 0)\n    return 100;\n  pp = (p < 1) ? p : 2 - p;\n  t = Math.sqrt(-2 * Math.log(pp / 2));\n  x = -0.70711 * ((2.30753 + t * 0.27061) /\n                  (1 + t * (0.99229 + t * 0.04481)) - t);\n  for (; j < 2; j++) {\n    err = jStat.erfc(x) - pp;\n    x += err / (1.12837916709551257 * Math.exp(-x * x) - x * err);\n  }\n  return (p < 1) ? x : -x;\n};\n\n\n// Returns the inverse of the incomplete beta function\njStat.ibetainv = function ibetainv(p, a, b) {\n  var EPS = 1e-8;\n  var a1 = a - 1;\n  var b1 = b - 1;\n  var j = 0;\n  var lna, lnb, pp, t, u, err, x, al, h, w, afac;\n  if (p <= 0)\n    return 0;\n  if (p >= 1)\n    return 1;\n  if (a >= 1 && b >= 1) {\n    pp = (p < 0.5) ? p : 1 - p;\n    t = Math.sqrt(-2 * Math.log(pp));\n    x = (2.30753 + t * 0.27061) / (1 + t* (0.99229 + t * 0.04481)) - t;\n    if (p < 0.5)\n      x = -x;\n    al = (x * x - 3) / 6;\n    h = 2 / (1 / (2 * a - 1)  + 1 / (2 * b - 1));\n    w = (x * Math.sqrt(al + h) / h) - (1 / (2 * b - 1) - 1 / (2 * a - 1)) *\n        (al + 5 / 6 - 2 / (3 * h));\n    x = a / (a + b * Math.exp(2 * w));\n  } else {\n    lna = Math.log(a / (a + b));\n    lnb = Math.log(b / (a + b));\n    t = Math.exp(a * lna) / a;\n    u = Math.exp(b * lnb) / b;\n    w = t + u;\n    if (p < t / w)\n      x = Math.pow(a * w * p, 1 / a);\n    else\n      x = 1 - Math.pow(b * w * (1 - p), 1 / b);\n  }\n  afac = -jStat.gammaln(a) - jStat.gammaln(b) + jStat.gammaln(a + b);\n  for(; j < 10; j++) {\n    if (x === 0 || x === 1)\n      return x;\n    err = jStat.ibeta(x, a, b) - p;\n    t = Math.exp(a1 * Math.log(x) + b1 * Math.log(1 - x) + afac);\n    u = err / t;\n    x -= (t = u / (1 - 0.5 * Math.min(1, u * (a1 / x - b1 / (1 - x)))));\n    if (x <= 0)\n      x = 0.5 * (x + t);\n    if (x >= 1)\n      x = 0.5 * (x + t + 1);\n    if (Math.abs(t) < EPS * x && j > 0)\n      break;\n  }\n  return x;\n};\n\n\n// Returns the incomplete beta function I_x(a,b)\njStat.ibeta = function ibeta(x, a, b) {\n  // Factors in front of the continued fraction.\n  var bt = (x === 0 || x === 1) ?  0 :\n    Math.exp(jStat.gammaln(a + b) - jStat.gammaln(a) -\n             jStat.gammaln(b) + a * Math.log(x) + b *\n             Math.log(1 - x));\n  if (x < 0 || x > 1)\n    return false;\n  if (x < (a + 1) / (a + b + 2))\n    // Use continued fraction directly.\n    return bt * jStat.betacf(x, a, b) / a;\n  // else use continued fraction after making the symmetry transformation.\n  return 1 - bt * jStat.betacf(1 - x, b, a) / b;\n};\n\n\n// Returns a normal deviate (mu=0, sigma=1).\n// If n and m are specified it returns a object of normal deviates.\njStat.randn = function randn(n, m) {\n  var u, v, x, y, q, mat;\n  if (!m)\n    m = n;\n  if (n)\n    return jStat.create(n, m, function() { return jStat.randn(); });\n  do {\n    u = Math.random();\n    v = 1.7156 * (Math.random() - 0.5);\n    x = u - 0.449871;\n    y = Math.abs(v) + 0.386595;\n    q = x * x + y * (0.19600 * y - 0.25472 * x);\n  } while (q > 0.27597 && (q > 0.27846 || v * v > -4 * Math.log(u) * u * u));\n  return v / u;\n};\n\n\n// Returns a gamma deviate by the method of Marsaglia and Tsang.\njStat.randg = function randg(shape, n, m) {\n  var oalph = shape;\n  var a1, a2, u, v, x, mat;\n  if (!m)\n    m = n;\n  if (!shape)\n    shape = 1;\n  if (n) {\n    mat = jStat.zeros(n,m);\n    mat.alter(function() { return jStat.randg(shape); });\n    return mat;\n  }\n  if (shape < 1)\n    shape += 1;\n  a1 = shape - 1 / 3;\n  a2 = 1 / Math.sqrt(9 * a1);\n  do {\n    do {\n      x = jStat.randn();\n      v = 1 + a2 * x;\n    } while(v <= 0);\n    v = v * v * v;\n    u = Math.random();\n  } while(u > 1 - 0.331 * Math.pow(x, 4) &&\n          Math.log(u) > 0.5 * x*x + a1 * (1 - v + Math.log(v)));\n  // alpha > 1\n  if (shape == oalph)\n    return a1 * v;\n  // alpha < 1\n  do {\n    u = Math.random();\n  } while(u === 0);\n  return Math.pow(u, 1 / oalph) * a1 * v;\n};\n\n\n// making use of static methods on the instance\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    jStat.fn[passfunc] = function() {\n      return jStat(\n          jStat.map(this, function(value) { return jStat[passfunc](value); }));\n    }\n  })(funcs[i]);\n})('gammaln gammafn factorial factorialln'.split(' '));\n\n\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    jStat.fn[passfunc] = function() {\n      return jStat(jStat[passfunc].apply(null, arguments));\n    };\n  })(funcs[i]);\n})('randn'.split(' '));\n\n}(jStat, Math));\n(function(jStat, Math) {\n\n// generate all distribution instance methods\n(function(list) {\n  for (var i = 0; i < list.length; i++) (function(func) {\n    // distribution instance method\n    jStat[func] = function(a, b, c) {\n      if (!(this instanceof arguments.callee))\n        return new arguments.callee(a, b, c);\n      this._a = a;\n      this._b = b;\n      this._c = c;\n      return this;\n    };\n    // distribution method to be used on a jStat instance\n    jStat.fn[func] = function(a, b, c) {\n      var newthis = jStat[func](a, b, c);\n      newthis.data = this;\n      return newthis;\n    };\n    // sample instance method\n    jStat[func].prototype.sample = function(arr) {\n      var a = this._a;\n      var b = this._b;\n      var c = this._c;\n      if (arr)\n        return jStat.alter(arr, function() {\n          return jStat[func].sample(a, b, c);\n        });\n      else\n        return jStat[func].sample(a, b, c);\n    };\n    // generate the pdf, cdf and inv instance methods\n    (function(vals) {\n      for (var i = 0; i < vals.length; i++) (function(fnfunc) {\n        jStat[func].prototype[fnfunc] = function(x) {\n          var a = this._a;\n          var b = this._b;\n          var c = this._c;\n          if (!x && x !== 0)\n            x = this.data;\n          if (typeof x !== 'number') {\n            return jStat.fn.map.call(x, function(x) {\n              return jStat[func][fnfunc](x, a, b, c);\n            });\n          }\n          return jStat[func][fnfunc](x, a, b, c);\n        };\n      })(vals[i]);\n    })('pdf cdf inv'.split(' '));\n    // generate the mean, median, mode and variance instance methods\n    (function(vals) {\n      for (var i = 0; i < vals.length; i++) (function(fnfunc) {\n        jStat[func].prototype[fnfunc] = function() {\n          return jStat[func][fnfunc](this._a, this._b, this._c);\n        };\n      })(vals[i]);\n    })('mean median mode variance'.split(' '));\n  })(list[i]);\n})((\n  'beta centralF cauchy chisquare exponential gamma invgamma kumaraswamy ' +\n  'laplace lognormal noncentralt normal pareto studentt weibull uniform ' +\n  'binomial negbin hypgeom poisson triangular tukey arcsine'\n).split(' '));\n\n\n\n// extend beta function with static methods\njStat.extend(jStat.beta, {\n  pdf: function pdf(x, alpha, beta) {\n    // PDF is zero outside the support\n    if (x > 1 || x < 0)\n      return 0;\n    // PDF is one for the uniform case\n    if (alpha == 1 && beta == 1)\n      return 1;\n\n    if (alpha < 512 && beta < 512) {\n      return (Math.pow(x, alpha - 1) * Math.pow(1 - x, beta - 1)) /\n          jStat.betafn(alpha, beta);\n    } else {\n      return Math.exp((alpha - 1) * Math.log(x) +\n                      (beta - 1) * Math.log(1 - x) -\n                      jStat.betaln(alpha, beta));\n    }\n  },\n\n  cdf: function cdf(x, alpha, beta) {\n    return (x > 1 || x < 0) ? (x > 1) * 1 : jStat.ibeta(x, alpha, beta);\n  },\n\n  inv: function inv(x, alpha, beta) {\n    return jStat.ibetainv(x, alpha, beta);\n  },\n\n  mean: function mean(alpha, beta) {\n    return alpha / (alpha + beta);\n  },\n\n  median: function median(alpha, beta) {\n    return jStat.ibetainv(0.5, alpha, beta);\n  },\n\n  mode: function mode(alpha, beta) {\n    return (alpha - 1 ) / ( alpha + beta - 2);\n  },\n\n  // return a random sample\n  sample: function sample(alpha, beta) {\n    var u = jStat.randg(alpha);\n    return u / (u + jStat.randg(beta));\n  },\n\n  variance: function variance(alpha, beta) {\n    return (alpha * beta) / (Math.pow(alpha + beta, 2) * (alpha + beta + 1));\n  }\n});\n\n// extend F function with static methods\njStat.extend(jStat.centralF, {\n  // This implementation of the pdf function avoids float overflow\n  // See the way that R calculates this value:\n  // https://svn.r-project.org/R/trunk/src/nmath/df.c\n  pdf: function pdf(x, df1, df2) {\n    var p, q, f;\n\n    if (x < 0)\n      return 0;\n\n    if (df1 <= 2) {\n      if (x === 0 && df1 < 2) {\n        return Infinity;\n      }\n      if (x === 0 && df1 === 2) {\n        return 1;\n      }\n      return (1 / jStat.betafn(df1 / 2, df2 / 2)) *\n              Math.pow(df1 / df2, df1 / 2) *\n              Math.pow(x, (df1/2) - 1) *\n              Math.pow((1 + (df1 / df2) * x), -(df1 + df2) / 2);\n    }\n\n    p = (df1 * x) / (df2 + x * df1);\n    q = df2 / (df2 + x * df1);\n    f = df1 * q / 2.0;\n    return f * jStat.binomial.pdf((df1 - 2) / 2, (df1 + df2 - 2) / 2, p);\n  },\n\n  cdf: function cdf(x, df1, df2) {\n    if (x < 0)\n      return 0;\n    return jStat.ibeta((df1 * x) / (df1 * x + df2), df1 / 2, df2 / 2);\n  },\n\n  inv: function inv(x, df1, df2) {\n    return df2 / (df1 * (1 / jStat.ibetainv(x, df1 / 2, df2 / 2) - 1));\n  },\n\n  mean: function mean(df1, df2) {\n    return (df2 > 2) ? df2 / (df2 - 2) : undefined;\n  },\n\n  mode: function mode(df1, df2) {\n    return (df1 > 2) ? (df2 * (df1 - 2)) / (df1 * (df2 + 2)) : undefined;\n  },\n\n  // return a random sample\n  sample: function sample(df1, df2) {\n    var x1 = jStat.randg(df1 / 2) * 2;\n    var x2 = jStat.randg(df2 / 2) * 2;\n    return (x1 / df1) / (x2 / df2);\n  },\n\n  variance: function variance(df1, df2) {\n    if (df2 <= 4)\n      return undefined;\n    return 2 * df2 * df2 * (df1 + df2 - 2) /\n        (df1 * (df2 - 2) * (df2 - 2) * (df2 - 4));\n  }\n});\n\n\n// extend cauchy function with static methods\njStat.extend(jStat.cauchy, {\n  pdf: function pdf(x, local, scale) {\n    if (scale < 0) { return 0; }\n\n    return (scale / (Math.pow(x - local, 2) + Math.pow(scale, 2))) / Math.PI;\n  },\n\n  cdf: function cdf(x, local, scale) {\n    return Math.atan((x - local) / scale) / Math.PI + 0.5;\n  },\n\n  inv: function(p, local, scale) {\n    return local + scale * Math.tan(Math.PI * (p - 0.5));\n  },\n\n  median: function median(local, scale) {\n    return local;\n  },\n\n  mode: function mode(local, scale) {\n    return local;\n  },\n\n  sample: function sample(local, scale) {\n    return jStat.randn() *\n        Math.sqrt(1 / (2 * jStat.randg(0.5))) * scale + local;\n  }\n});\n\n\n\n// extend chisquare function with static methods\njStat.extend(jStat.chisquare, {\n  pdf: function pdf(x, dof) {\n    if (x < 0)\n      return 0;\n    return (x === 0 && dof === 2) ? 0.5 :\n        Math.exp((dof / 2 - 1) * Math.log(x) - x / 2 - (dof / 2) *\n                 Math.log(2) - jStat.gammaln(dof / 2));\n  },\n\n  cdf: function cdf(x, dof) {\n    if (x < 0)\n      return 0;\n    return jStat.lowRegGamma(dof / 2, x / 2);\n  },\n\n  inv: function(p, dof) {\n    return 2 * jStat.gammapinv(p, 0.5 * dof);\n  },\n\n  mean : function(dof) {\n    return dof;\n  },\n\n  // TODO: this is an approximation (is there a better way?)\n  median: function median(dof) {\n    return dof * Math.pow(1 - (2 / (9 * dof)), 3);\n  },\n\n  mode: function mode(dof) {\n    return (dof - 2 > 0) ? dof - 2 : 0;\n  },\n\n  sample: function sample(dof) {\n    return jStat.randg(dof / 2) * 2;\n  },\n\n  variance: function variance(dof) {\n    return 2 * dof;\n  }\n});\n\n\n\n// extend exponential function with static methods\njStat.extend(jStat.exponential, {\n  pdf: function pdf(x, rate) {\n    return x < 0 ? 0 : rate * Math.exp(-rate * x);\n  },\n\n  cdf: function cdf(x, rate) {\n    return x < 0 ? 0 : 1 - Math.exp(-rate * x);\n  },\n\n  inv: function(p, rate) {\n    return -Math.log(1 - p) / rate;\n  },\n\n  mean : function(rate) {\n    return 1 / rate;\n  },\n\n  median: function (rate) {\n    return (1 / rate) * Math.log(2);\n  },\n\n  mode: function mode(rate) {\n    return 0;\n  },\n\n  sample: function sample(rate) {\n    return -1 / rate * Math.log(Math.random());\n  },\n\n  variance : function(rate) {\n    return Math.pow(rate, -2);\n  }\n});\n\n\n\n// extend gamma function with static methods\njStat.extend(jStat.gamma, {\n  pdf: function pdf(x, shape, scale) {\n    if (x < 0)\n      return 0;\n    return (x === 0 && shape === 1) ? 1 / scale :\n            Math.exp((shape - 1) * Math.log(x) - x / scale -\n                    jStat.gammaln(shape) - shape * Math.log(scale));\n  },\n\n  cdf: function cdf(x, shape, scale) {\n    if (x < 0)\n      return 0;\n    return jStat.lowRegGamma(shape, x / scale);\n  },\n\n  inv: function(p, shape, scale) {\n    return jStat.gammapinv(p, shape) * scale;\n  },\n\n  mean : function(shape, scale) {\n    return shape * scale;\n  },\n\n  mode: function mode(shape, scale) {\n    if(shape > 1) return (shape - 1) * scale;\n    return undefined;\n  },\n\n  sample: function sample(shape, scale) {\n    return jStat.randg(shape) * scale;\n  },\n\n  variance: function variance(shape, scale) {\n    return shape * scale * scale;\n  }\n});\n\n// extend inverse gamma function with static methods\njStat.extend(jStat.invgamma, {\n  pdf: function pdf(x, shape, scale) {\n    if (x <= 0)\n      return 0;\n    return Math.exp(-(shape + 1) * Math.log(x) - scale / x -\n                    jStat.gammaln(shape) + shape * Math.log(scale));\n  },\n\n  cdf: function cdf(x, shape, scale) {\n    if (x <= 0)\n      return 0;\n    return 1 - jStat.lowRegGamma(shape, scale / x);\n  },\n\n  inv: function(p, shape, scale) {\n    return scale / jStat.gammapinv(1 - p, shape);\n  },\n\n  mean : function(shape, scale) {\n    return (shape > 1) ? scale / (shape - 1) : undefined;\n  },\n\n  mode: function mode(shape, scale) {\n    return scale / (shape + 1);\n  },\n\n  sample: function sample(shape, scale) {\n    return scale / jStat.randg(shape);\n  },\n\n  variance: function variance(shape, scale) {\n    if (shape <= 2)\n      return undefined;\n    return scale * scale / ((shape - 1) * (shape - 1) * (shape - 2));\n  }\n});\n\n\n// extend kumaraswamy function with static methods\njStat.extend(jStat.kumaraswamy, {\n  pdf: function pdf(x, alpha, beta) {\n    if (x === 0 && alpha === 1)\n      return beta;\n    else if (x === 1 && beta === 1)\n      return alpha;\n    return Math.exp(Math.log(alpha) + Math.log(beta) + (alpha - 1) *\n                    Math.log(x) + (beta - 1) *\n                    Math.log(1 - Math.pow(x, alpha)));\n  },\n\n  cdf: function cdf(x, alpha, beta) {\n    if (x < 0)\n      return 0;\n    else if (x > 1)\n      return 1;\n    return (1 - Math.pow(1 - Math.pow(x, alpha), beta));\n  },\n\n  inv: function inv(p, alpha, beta) {\n    return Math.pow(1 - Math.pow(1 - p, 1 / beta), 1 / alpha);\n  },\n\n  mean : function(alpha, beta) {\n    return (beta * jStat.gammafn(1 + 1 / alpha) *\n            jStat.gammafn(beta)) / (jStat.gammafn(1 + 1 / alpha + beta));\n  },\n\n  median: function median(alpha, beta) {\n    return Math.pow(1 - Math.pow(2, -1 / beta), 1 / alpha);\n  },\n\n  mode: function mode(alpha, beta) {\n    if (!(alpha >= 1 && beta >= 1 && (alpha !== 1 && beta !== 1)))\n      return undefined;\n    return Math.pow((alpha - 1) / (alpha * beta - 1), 1 / alpha);\n  },\n\n  variance: function variance(alpha, beta) {\n    throw new Error('variance not yet implemented');\n    // TODO: complete this\n  }\n});\n\n\n\n// extend lognormal function with static methods\njStat.extend(jStat.lognormal, {\n  pdf: function pdf(x, mu, sigma) {\n    if (x <= 0)\n      return 0;\n    return Math.exp(-Math.log(x) - 0.5 * Math.log(2 * Math.PI) -\n                    Math.log(sigma) - Math.pow(Math.log(x) - mu, 2) /\n                    (2 * sigma * sigma));\n  },\n\n  cdf: function cdf(x, mu, sigma) {\n    if (x < 0)\n      return 0;\n    return 0.5 +\n        (0.5 * jStat.erf((Math.log(x) - mu) / Math.sqrt(2 * sigma * sigma)));\n  },\n\n  inv: function(p, mu, sigma) {\n    return Math.exp(-1.41421356237309505 * sigma * jStat.erfcinv(2 * p) + mu);\n  },\n\n  mean: function mean(mu, sigma) {\n    return Math.exp(mu + sigma * sigma / 2);\n  },\n\n  median: function median(mu, sigma) {\n    return Math.exp(mu);\n  },\n\n  mode: function mode(mu, sigma) {\n    return Math.exp(mu - sigma * sigma);\n  },\n\n  sample: function sample(mu, sigma) {\n    return Math.exp(jStat.randn() * sigma + mu);\n  },\n\n  variance: function variance(mu, sigma) {\n    return (Math.exp(sigma * sigma) - 1) * Math.exp(2 * mu + sigma * sigma);\n  }\n});\n\n\n\n// extend noncentralt function with static methods\njStat.extend(jStat.noncentralt, {\n  pdf: function pdf(x, dof, ncp) {\n    var tol = 1e-14;\n    if (Math.abs(ncp) < tol)  // ncp approx 0; use student-t\n      return jStat.studentt.pdf(x, dof)\n\n    if (Math.abs(x) < tol) {  // different formula for x == 0\n      return Math.exp(jStat.gammaln((dof + 1) / 2) - ncp * ncp / 2 -\n                      0.5 * Math.log(Math.PI * dof) - jStat.gammaln(dof / 2));\n    }\n\n    // formula for x != 0\n    return dof / x *\n        (jStat.noncentralt.cdf(x * Math.sqrt(1 + 2 / dof), dof+2, ncp) -\n         jStat.noncentralt.cdf(x, dof, ncp));\n  },\n\n  cdf: function cdf(x, dof, ncp) {\n    var tol = 1e-14;\n    var min_iterations = 200;\n\n    if (Math.abs(ncp) < tol)  // ncp approx 0; use student-t\n      return jStat.studentt.cdf(x, dof);\n\n    // turn negative x into positive and flip result afterwards\n    var flip = false;\n    if (x < 0) {\n      flip = true;\n      ncp = -ncp;\n    }\n\n    var prob = jStat.normal.cdf(-ncp, 0, 1);\n    var value = tol + 1;\n    // use value at last two steps to determine convergence\n    var lastvalue = value;\n    var y = x * x / (x * x + dof);\n    var j = 0;\n    var p = Math.exp(-ncp * ncp / 2);\n    var q = Math.exp(-ncp * ncp / 2 - 0.5 * Math.log(2) -\n                     jStat.gammaln(3 / 2)) * ncp;\n    while (j < min_iterations || lastvalue > tol || value > tol) {\n      lastvalue = value;\n      if (j > 0) {\n        p *= (ncp * ncp) / (2 * j);\n        q *= (ncp * ncp) / (2 * (j + 1 / 2));\n      }\n      value = p * jStat.beta.cdf(y, j + 0.5, dof / 2) +\n          q * jStat.beta.cdf(y, j+1, dof/2);\n      prob += 0.5 * value;\n      j++;\n    }\n\n    return flip ? (1 - prob) : prob;\n  }\n});\n\n\n// extend normal function with static methods\njStat.extend(jStat.normal, {\n  pdf: function pdf(x, mean, std) {\n    return Math.exp(-0.5 * Math.log(2 * Math.PI) -\n                    Math.log(std) - Math.pow(x - mean, 2) / (2 * std * std));\n  },\n\n  cdf: function cdf(x, mean, std) {\n    return 0.5 * (1 + jStat.erf((x - mean) / Math.sqrt(2 * std * std)));\n  },\n\n  inv: function(p, mean, std) {\n    return -1.41421356237309505 * std * jStat.erfcinv(2 * p) + mean;\n  },\n\n  mean : function(mean, std) {\n    return mean;\n  },\n\n  median: function median(mean, std) {\n    return mean;\n  },\n\n  mode: function (mean, std) {\n    return mean;\n  },\n\n  sample: function sample(mean, std) {\n    return jStat.randn() * std + mean;\n  },\n\n  variance : function(mean, std) {\n    return std * std;\n  }\n});\n\n\n\n// extend pareto function with static methods\njStat.extend(jStat.pareto, {\n  pdf: function pdf(x, scale, shape) {\n    if (x < scale)\n      return 0;\n    return (shape * Math.pow(scale, shape)) / Math.pow(x, shape + 1);\n  },\n\n  cdf: function cdf(x, scale, shape) {\n    if (x < scale)\n      return 0;\n    return 1 - Math.pow(scale / x, shape);\n  },\n\n  inv: function inv(p, scale, shape) {\n    return scale / Math.pow(1 - p, 1 / shape);\n  },\n\n  mean: function mean(scale, shape) {\n    if (shape <= 1)\n      return undefined;\n    return (shape * Math.pow(scale, shape)) / (shape - 1);\n  },\n\n  median: function median(scale, shape) {\n    return scale * (shape * Math.SQRT2);\n  },\n\n  mode: function mode(scale, shape) {\n    return scale;\n  },\n\n  variance : function(scale, shape) {\n    if (shape <= 2)\n      return undefined;\n    return (scale*scale * shape) / (Math.pow(shape - 1, 2) * (shape - 2));\n  }\n});\n\n\n\n// extend studentt function with static methods\njStat.extend(jStat.studentt, {\n  pdf: function pdf(x, dof) {\n    dof = dof > 1e100 ? 1e100 : dof;\n    return (1/(Math.sqrt(dof) * jStat.betafn(0.5, dof/2))) *\n        Math.pow(1 + ((x * x) / dof), -((dof + 1) / 2));\n  },\n\n  cdf: function cdf(x, dof) {\n    var dof2 = dof / 2;\n    return jStat.ibeta((x + Math.sqrt(x * x + dof)) /\n                       (2 * Math.sqrt(x * x + dof)), dof2, dof2);\n  },\n\n  inv: function(p, dof) {\n    var x = jStat.ibetainv(2 * Math.min(p, 1 - p), 0.5 * dof, 0.5);\n    x = Math.sqrt(dof * (1 - x) / x);\n    return (p > 0.5) ? x : -x;\n  },\n\n  mean: function mean(dof) {\n    return (dof > 1) ? 0 : undefined;\n  },\n\n  median: function median(dof) {\n    return 0;\n  },\n\n  mode: function mode(dof) {\n    return 0;\n  },\n\n  sample: function sample(dof) {\n    return jStat.randn() * Math.sqrt(dof / (2 * jStat.randg(dof / 2)));\n  },\n\n  variance: function variance(dof) {\n    return (dof  > 2) ? dof / (dof - 2) : (dof > 1) ? Infinity : undefined;\n  }\n});\n\n\n\n// extend weibull function with static methods\njStat.extend(jStat.weibull, {\n  pdf: function pdf(x, scale, shape) {\n    if (x < 0 || scale < 0 || shape < 0)\n      return 0;\n    return (shape / scale) * Math.pow((x / scale), (shape - 1)) *\n        Math.exp(-(Math.pow((x / scale), shape)));\n  },\n\n  cdf: function cdf(x, scale, shape) {\n    return x < 0 ? 0 : 1 - Math.exp(-Math.pow((x / scale), shape));\n  },\n\n  inv: function(p, scale, shape) {\n    return scale * Math.pow(-Math.log(1 - p), 1 / shape);\n  },\n\n  mean : function(scale, shape) {\n    return scale * jStat.gammafn(1 + 1 / shape);\n  },\n\n  median: function median(scale, shape) {\n    return scale * Math.pow(Math.log(2), 1 / shape);\n  },\n\n  mode: function mode(scale, shape) {\n    if (shape <= 1)\n      return 0;\n    return scale * Math.pow((shape - 1) / shape, 1 / shape);\n  },\n\n  sample: function sample(scale, shape) {\n    return scale * Math.pow(-Math.log(Math.random()), 1 / shape);\n  },\n\n  variance: function variance(scale, shape) {\n    return scale * scale * jStat.gammafn(1 + 2 / shape) -\n        Math.pow(jStat.weibull.mean(scale, shape), 2);\n  }\n});\n\n\n\n// extend uniform function with static methods\njStat.extend(jStat.uniform, {\n  pdf: function pdf(x, a, b) {\n    return (x < a || x > b) ? 0 : 1 / (b - a);\n  },\n\n  cdf: function cdf(x, a, b) {\n    if (x < a)\n      return 0;\n    else if (x < b)\n      return (x - a) / (b - a);\n    return 1;\n  },\n\n  inv: function(p, a, b) {\n    return a + (p * (b - a));\n  },\n\n  mean: function mean(a, b) {\n    return 0.5 * (a + b);\n  },\n\n  median: function median(a, b) {\n    return jStat.mean(a, b);\n  },\n\n  mode: function mode(a, b) {\n    throw new Error('mode is not yet implemented');\n  },\n\n  sample: function sample(a, b) {\n    return (a / 2 + b / 2) + (b / 2 - a / 2) * (2 * Math.random() - 1);\n  },\n\n  variance: function variance(a, b) {\n    return Math.pow(b - a, 2) / 12;\n  }\n});\n\n\n\n// extend uniform function with static methods\njStat.extend(jStat.binomial, {\n  pdf: function pdf(k, n, p) {\n    return (p === 0 || p === 1) ?\n      ((n * p) === k ? 1 : 0) :\n      jStat.combination(n, k) * Math.pow(p, k) * Math.pow(1 - p, n - k);\n  },\n\n  cdf: function cdf(x, n, p) {\n    var binomarr = [],\n    k = 0;\n    if (x < 0) {\n      return 0;\n    }\n    if (x < n) {\n      for (; k <= x; k++) {\n        binomarr[ k ] = jStat.binomial.pdf(k, n, p);\n      }\n      return jStat.sum(binomarr);\n    }\n    return 1;\n  }\n});\n\n\n\n// extend uniform function with static methods\njStat.extend(jStat.negbin, {\n  pdf: function pdf(k, r, p) {\n    if (k !== k >>> 0)\n      return false;\n    if (k < 0)\n      return 0;\n    return jStat.combination(k + r - 1, r - 1) *\n        Math.pow(1 - p, k) * Math.pow(p, r);\n  },\n\n  cdf: function cdf(x, r, p) {\n    var sum = 0,\n    k = 0;\n    if (x < 0) return 0;\n    for (; k <= x; k++) {\n      sum += jStat.negbin.pdf(k, r, p);\n    }\n    return sum;\n  }\n});\n\n\n\n// extend uniform function with static methods\njStat.extend(jStat.hypgeom, {\n  pdf: function pdf(k, N, m, n) {\n    // Hypergeometric PDF.\n\n    // A simplification of the CDF algorithm below.\n\n    // k = number of successes drawn\n    // N = population size\n    // m = number of successes in population\n    // n = number of items drawn from population\n\n    if(k !== k | 0) {\n      return false;\n    } else if(k < 0 || k < m - (N - n)) {\n      // It's impossible to have this few successes drawn.\n      return 0;\n    } else if(k > n || k > m) {\n      // It's impossible to have this many successes drawn.\n      return 0;\n    } else if (m * 2 > N) {\n      // More than half the population is successes.\n\n      if(n * 2 > N) {\n        // More than half the population is sampled.\n\n        return jStat.hypgeom.pdf(N - m - n + k, N, N - m, N - n)\n      } else {\n        // Half or less of the population is sampled.\n\n        return jStat.hypgeom.pdf(n - k, N, N - m, n);\n      }\n\n    } else if(n * 2 > N) {\n      // Half or less is successes.\n\n      return jStat.hypgeom.pdf(m - k, N, m, N - n);\n\n    } else if(m < n) {\n      // We want to have the number of things sampled to be less than the\n      // successes available. So swap the definitions of successful and sampled.\n      return jStat.hypgeom.pdf(k, N, n, m);\n    } else {\n      // If we get here, half or less of the population was sampled, half or\n      // less of it was successes, and we had fewer sampled things than\n      // successes. Now we can do this complicated iterative algorithm in an\n      // efficient way.\n\n      // The basic premise of the algorithm is that we partially normalize our\n      // intermediate product to keep it in a numerically good region, and then\n      // finish the normalization at the end.\n\n      // This variable holds the scaled probability of the current number of\n      // successes.\n      var scaledPDF = 1;\n\n      // This keeps track of how much we have normalized.\n      var samplesDone = 0;\n\n      for(var i = 0; i < k; i++) {\n        // For every possible number of successes up to that observed...\n\n        while(scaledPDF > 1 && samplesDone < n) {\n          // Intermediate result is growing too big. Apply some of the\n          // normalization to shrink everything.\n\n          scaledPDF *= 1 - (m / (N - samplesDone));\n\n          // Say we've normalized by this sample already.\n          samplesDone++;\n        }\n\n        // Work out the partially-normalized hypergeometric PDF for the next\n        // number of successes\n        scaledPDF *= (n - i) * (m - i) / ((i + 1) * (N - m - n + i + 1));\n      }\n\n      for(; samplesDone < n; samplesDone++) {\n        // Apply all the rest of the normalization\n        scaledPDF *= 1 - (m / (N - samplesDone));\n      }\n\n      // Bound answer sanely before returning.\n      return Math.min(1, Math.max(0, scaledPDF));\n    }\n  },\n\n  cdf: function cdf(x, N, m, n) {\n    // Hypergeometric CDF.\n\n    // This algorithm is due to Prof. Thomas S. Ferguson, <tom@math.ucla.edu>,\n    // and comes from his hypergeometric test calculator at\n    // <http://www.math.ucla.edu/~tom/distributions/Hypergeometric.html>.\n\n    // x = number of successes drawn\n    // N = population size\n    // m = number of successes in population\n    // n = number of items drawn from population\n\n    if(x < 0 || x < m - (N - n)) {\n      // It's impossible to have this few successes drawn or fewer.\n      return 0;\n    } else if(x >= n || x >= m) {\n      // We will always have this many successes or fewer.\n      return 1;\n    } else if (m * 2 > N) {\n      // More than half the population is successes.\n\n      if(n * 2 > N) {\n        // More than half the population is sampled.\n\n        return jStat.hypgeom.cdf(N - m - n + x, N, N - m, N - n)\n      } else {\n        // Half or less of the population is sampled.\n\n        return 1 - jStat.hypgeom.cdf(n - x - 1, N, N - m, n);\n      }\n\n    } else if(n * 2 > N) {\n      // Half or less is successes.\n\n      return 1 - jStat.hypgeom.cdf(m - x - 1, N, m, N - n);\n\n    } else if(m < n) {\n      // We want to have the number of things sampled to be less than the\n      // successes available. So swap the definitions of successful and sampled.\n      return jStat.hypgeom.cdf(x, N, n, m);\n    } else {\n      // If we get here, half or less of the population was sampled, half or\n      // less of it was successes, and we had fewer sampled things than\n      // successes. Now we can do this complicated iterative algorithm in an\n      // efficient way.\n\n      // The basic premise of the algorithm is that we partially normalize our\n      // intermediate sum to keep it in a numerically good region, and then\n      // finish the normalization at the end.\n\n      // Holds the intermediate, scaled total CDF.\n      var scaledCDF = 1;\n\n      // This variable holds the scaled probability of the current number of\n      // successes.\n      var scaledPDF = 1;\n\n      // This keeps track of how much we have normalized.\n      var samplesDone = 0;\n\n      for(var i = 0; i < x; i++) {\n        // For every possible number of successes up to that observed...\n\n        while(scaledCDF > 1 && samplesDone < n) {\n          // Intermediate result is growing too big. Apply some of the\n          // normalization to shrink everything.\n\n          var factor = 1 - (m / (N - samplesDone));\n\n          scaledPDF *= factor;\n          scaledCDF *= factor;\n\n          // Say we've normalized by this sample already.\n          samplesDone++;\n        }\n\n        // Work out the partially-normalized hypergeometric PDF for the next\n        // number of successes\n        scaledPDF *= (n - i) * (m - i) / ((i + 1) * (N - m - n + i + 1));\n\n        // Add to the CDF answer.\n        scaledCDF += scaledPDF;\n      }\n\n      for(; samplesDone < n; samplesDone++) {\n        // Apply all the rest of the normalization\n        scaledCDF *= 1 - (m / (N - samplesDone));\n      }\n\n      // Bound answer sanely before returning.\n      return Math.min(1, Math.max(0, scaledCDF));\n    }\n  }\n});\n\n\n\n// extend uniform function with static methods\njStat.extend(jStat.poisson, {\n  pdf: function pdf(k, l) {\n    if (l < 0 || (k % 1) !== 0 || k < 0) {\n      return 0;\n    }\n\n    return Math.pow(l, k) * Math.exp(-l) / jStat.factorial(k);\n  },\n\n  cdf: function cdf(x, l) {\n    var sumarr = [],\n    k = 0;\n    if (x < 0) return 0;\n    for (; k <= x; k++) {\n      sumarr.push(jStat.poisson.pdf(k, l));\n    }\n    return jStat.sum(sumarr);\n  },\n\n  mean : function(l) {\n    return l;\n  },\n\n  variance : function(l) {\n    return l;\n  },\n\n  sample: function sample(l) {\n    var p = 1, k = 0, L = Math.exp(-l);\n    do {\n      k++;\n      p *= Math.random();\n    } while (p > L);\n    return k - 1;\n  }\n});\n\n// extend triangular function with static methods\njStat.extend(jStat.triangular, {\n  pdf: function pdf(x, a, b, c) {\n    if (b <= a || c < a || c > b) {\n      return NaN;\n    } else {\n      if (x < a || x > b) {\n        return 0;\n      } else if (x < c) {\n          return (2 * (x - a)) / ((b - a) * (c - a));\n      } else if (x === c) {\n          return (2 / (b - a));\n      } else { // x > c\n          return (2 * (b - x)) / ((b - a) * (b - c));\n      }\n    }\n  },\n\n  cdf: function cdf(x, a, b, c) {\n    if (b <= a || c < a || c > b)\n      return NaN;\n    if (x <= a)\n      return 0;\n    else if (x >= b)\n      return 1;\n    if (x <= c)\n      return Math.pow(x - a, 2) / ((b - a) * (c - a));\n    else // x > c\n      return 1 - Math.pow(b - x, 2) / ((b - a) * (b - c));\n  },\n\n  inv: function inv(p, a, b, c) {\n    if (b <= a || c < a || c > b) {\n      return NaN;\n    } else {\n      if (p <= ((c - a) / (b - a))) {\n        return a + (b - a) * Math.sqrt(p * ((c - a) / (b - a)));\n      } else { // p > ((c - a) / (b - a))\n        return a + (b - a) * (1 - Math.sqrt((1 - p) * (1 - ((c - a) / (b - a)))));\n      }\n    }\n  },\n\n  mean: function mean(a, b, c) {\n    return (a + b + c) / 3;\n  },\n\n  median: function median(a, b, c) {\n    if (c <= (a + b) / 2) {\n      return b - Math.sqrt((b - a) * (b - c)) / Math.sqrt(2);\n    } else if (c > (a + b) / 2) {\n      return a + Math.sqrt((b - a) * (c - a)) / Math.sqrt(2);\n    }\n  },\n\n  mode: function mode(a, b, c) {\n    return c;\n  },\n\n  sample: function sample(a, b, c) {\n    var u = Math.random();\n    if (u < ((c - a) / (b - a)))\n      return a + Math.sqrt(u * (b - a) * (c - a))\n    return b - Math.sqrt((1 - u) * (b - a) * (b - c));\n  },\n\n  variance: function variance(a, b, c) {\n    return (a * a + b * b + c * c - a * b - a * c - b * c) / 18;\n  }\n});\n\n\n// extend arcsine function with static methods\njStat.extend(jStat.arcsine, {\n  pdf: function pdf(x, a, b) {\n    if (b <= a) return NaN;\n\n    return (x <= a || x >= b) ? 0 :\n      (2 / Math.PI) *\n        Math.pow(Math.pow(b - a, 2) -\n                  Math.pow(2 * x - a - b, 2), -0.5);\n  },\n\n  cdf: function cdf(x, a, b) {\n    if (x < a)\n      return 0;\n    else if (x < b)\n      return (2 / Math.PI) * Math.asin(Math.sqrt((x - a)/(b - a)));\n    return 1;\n  },\n\n  inv: function(p, a, b) {\n    return a + (0.5 - 0.5 * Math.cos(Math.PI * p)) * (b - a);\n  },\n\n  mean: function mean(a, b) {\n    if (b <= a) return NaN;\n    return (a + b) / 2;\n  },\n\n  median: function median(a, b) {\n    if (b <= a) return NaN;\n    return (a + b) / 2;\n  },\n\n  mode: function mode(a, b) {\n    throw new Error('mode is not yet implemented');\n  },\n\n  sample: function sample(a, b) {\n    return ((a + b) / 2) + ((b - a) / 2) *\n      Math.sin(2 * Math.PI * jStat.uniform.sample(0, 1));\n  },\n\n  variance: function variance(a, b) {\n    if (b <= a) return NaN;\n    return Math.pow(b - a, 2) / 8;\n  }\n});\n\n\nfunction laplaceSign(x) { return x / Math.abs(x); }\n\njStat.extend(jStat.laplace, {\n  pdf: function pdf(x, mu, b) {\n    return (b <= 0) ? 0 : (Math.exp(-Math.abs(x - mu) / b)) / (2 * b);\n  },\n\n  cdf: function cdf(x, mu, b) {\n    if (b <= 0) { return 0; }\n\n    if(x < mu) {\n      return 0.5 * Math.exp((x - mu) / b);\n    } else {\n      return 1 - 0.5 * Math.exp(- (x - mu) / b);\n    }\n  },\n\n  mean: function(mu, b) {\n    return mu;\n  },\n\n  median: function(mu, b) {\n    return mu;\n  },\n\n  mode: function(mu, b) {\n    return mu;\n  },\n\n  variance: function(mu, b) {\n    return 2 * b * b;\n  },\n\n  sample: function sample(mu, b) {\n    var u = Math.random() - 0.5;\n\n    return mu - (b * laplaceSign(u) * Math.log(1 - (2 * Math.abs(u))));\n  }\n});\n\nfunction tukeyWprob(w, rr, cc) {\n  var nleg = 12;\n  var ihalf = 6;\n\n  var C1 = -30;\n  var C2 = -50;\n  var C3 = 60;\n  var bb   = 8;\n  var wlar = 3;\n  var wincr1 = 2;\n  var wincr2 = 3;\n  var xleg = [\n    0.981560634246719250690549090149,\n    0.904117256370474856678465866119,\n    0.769902674194304687036893833213,\n    0.587317954286617447296702418941,\n    0.367831498998180193752691536644,\n    0.125233408511468915472441369464\n  ];\n  var aleg = [\n    0.047175336386511827194615961485,\n    0.106939325995318430960254718194,\n    0.160078328543346226334652529543,\n    0.203167426723065921749064455810,\n    0.233492536538354808760849898925,\n    0.249147045813402785000562436043\n  ];\n\n  var qsqz = w * 0.5;\n\n  // if w >= 16 then the integral lower bound (occurs for c=20)\n  // is 0.99999999999995 so return a value of 1.\n\n  if (qsqz >= bb)\n    return 1.0;\n\n  // find (f(w/2) - 1) ^ cc\n  // (first term in integral of hartley's form).\n\n  var pr_w = 2 * jStat.normal.cdf(qsqz, 0, 1, 1, 0) - 1; // erf(qsqz / M_SQRT2)\n  // if pr_w ^ cc < 2e-22 then set pr_w = 0\n  if (pr_w >= Math.exp(C2 / cc))\n    pr_w = Math.pow(pr_w, cc);\n  else\n    pr_w = 0.0;\n\n  // if w is large then the second component of the\n  // integral is small, so fewer intervals are needed.\n\n  var wincr;\n  if (w > wlar)\n    wincr = wincr1;\n  else\n    wincr = wincr2;\n\n  // find the integral of second term of hartley's form\n  // for the integral of the range for equal-length\n  // intervals using legendre quadrature.  limits of\n  // integration are from (w/2, 8).  two or three\n  // equal-length intervals are used.\n\n  // blb and bub are lower and upper limits of integration.\n\n  var blb = qsqz;\n  var binc = (bb - qsqz) / wincr;\n  var bub = blb + binc;\n  var einsum = 0.0;\n\n  // integrate over each interval\n\n  var cc1 = cc - 1.0;\n  for (var wi = 1; wi <= wincr; wi++) {\n    var elsum = 0.0;\n    var a = 0.5 * (bub + blb);\n\n    // legendre quadrature with order = nleg\n\n    var b = 0.5 * (bub - blb);\n\n    for (var jj = 1; jj <= nleg; jj++) {\n      var j, xx;\n      if (ihalf < jj) {\n        j = (nleg - jj) + 1;\n        xx = xleg[j-1];\n      } else {\n        j = jj;\n        xx = -xleg[j-1];\n      }\n      var c = b * xx;\n      var ac = a + c;\n\n      // if exp(-qexpo/2) < 9e-14,\n      // then doesn't contribute to integral\n\n      var qexpo = ac * ac;\n      if (qexpo > C3)\n        break;\n\n      var pplus = 2 * jStat.normal.cdf(ac, 0, 1, 1, 0);\n      var pminus= 2 * jStat.normal.cdf(ac, w, 1, 1, 0);\n\n      // if rinsum ^ (cc-1) < 9e-14,\n      // then doesn't contribute to integral\n\n      var rinsum = (pplus * 0.5) - (pminus * 0.5);\n      if (rinsum >= Math.exp(C1 / cc1)) {\n        rinsum = (aleg[j-1] * Math.exp(-(0.5 * qexpo))) * Math.pow(rinsum, cc1);\n        elsum += rinsum;\n      }\n    }\n    elsum *= (((2.0 * b) * cc) / Math.sqrt(2 * Math.PI));\n    einsum += elsum;\n    blb = bub;\n    bub += binc;\n  }\n\n  // if pr_w ^ rr < 9e-14, then return 0\n  pr_w += einsum;\n  if (pr_w <= Math.exp(C1 / rr))\n    return 0;\n\n  pr_w = Math.pow(pr_w, rr);\n  if (pr_w >= 1) // 1 was iMax was eps\n    return 1;\n  return pr_w;\n}\n\nfunction tukeyQinv(p, c, v) {\n  var p0 = 0.322232421088;\n  var q0 = 0.993484626060e-01;\n  var p1 = -1.0;\n  var q1 = 0.588581570495;\n  var p2 = -0.342242088547;\n  var q2 = 0.531103462366;\n  var p3 = -0.204231210125;\n  var q3 = 0.103537752850;\n  var p4 = -0.453642210148e-04;\n  var q4 = 0.38560700634e-02;\n  var c1 = 0.8832;\n  var c2 = 0.2368;\n  var c3 = 1.214;\n  var c4 = 1.208;\n  var c5 = 1.4142;\n  var vmax = 120.0;\n\n  var ps = 0.5 - 0.5 * p;\n  var yi = Math.sqrt(Math.log(1.0 / (ps * ps)));\n  var t = yi + (((( yi * p4 + p3) * yi + p2) * yi + p1) * yi + p0)\n     / (((( yi * q4 + q3) * yi + q2) * yi + q1) * yi + q0);\n  if (v < vmax) t += (t * t * t + t) / v / 4.0;\n  var q = c1 - c2 * t;\n  if (v < vmax) q += -c3 / v + c4 * t / v;\n  return t * (q * Math.log(c - 1.0) + c5);\n}\n\njStat.extend(jStat.tukey, {\n  cdf: function cdf(q, nmeans, df) {\n    // Identical implementation as the R ptukey() function as of commit 68947\n    var rr = 1;\n    var cc = nmeans;\n\n    var nlegq = 16;\n    var ihalfq = 8;\n\n    var eps1 = -30.0;\n    var eps2 = 1.0e-14;\n    var dhaf  = 100.0;\n    var dquar = 800.0;\n    var deigh = 5000.0;\n    var dlarg = 25000.0;\n    var ulen1 = 1.0;\n    var ulen2 = 0.5;\n    var ulen3 = 0.25;\n    var ulen4 = 0.125;\n    var xlegq = [\n      0.989400934991649932596154173450,\n      0.944575023073232576077988415535,\n      0.865631202387831743880467897712,\n      0.755404408355003033895101194847,\n      0.617876244402643748446671764049,\n      0.458016777657227386342419442984,\n      0.281603550779258913230460501460,\n      0.950125098376374401853193354250e-1\n    ];\n    var alegq = [\n      0.271524594117540948517805724560e-1,\n      0.622535239386478928628438369944e-1,\n      0.951585116824927848099251076022e-1,\n      0.124628971255533872052476282192,\n      0.149595988816576732081501730547,\n      0.169156519395002538189312079030,\n      0.182603415044923588866763667969,\n      0.189450610455068496285396723208\n    ];\n\n    if (q <= 0)\n      return 0;\n\n    // df must be > 1\n    // there must be at least two values\n\n    if (df < 2 || rr < 1 || cc < 2) return NaN;\n\n    if (!Number.isFinite(q))\n      return 1;\n\n    if (df > dlarg)\n      return tukeyWprob(q, rr, cc);\n\n    // calculate leading constant\n\n    var f2 = df * 0.5;\n    var f2lf = ((f2 * Math.log(df)) - (df * Math.log(2))) - jStat.gammaln(f2);\n    var f21 = f2 - 1.0;\n\n    // integral is divided into unit, half-unit, quarter-unit, or\n    // eighth-unit length intervals depending on the value of the\n    // degrees of freedom.\n\n    var ff4 = df * 0.25;\n    var ulen;\n    if      (df <= dhaf)  ulen = ulen1;\n    else if (df <= dquar) ulen = ulen2;\n    else if (df <= deigh) ulen = ulen3;\n    else                  ulen = ulen4;\n\n    f2lf += Math.log(ulen);\n\n    // integrate over each subinterval\n\n    var ans = 0.0;\n\n    for (var i = 1; i <= 50; i++) {\n      var otsum = 0.0;\n\n      // legendre quadrature with order = nlegq\n      // nodes (stored in xlegq) are symmetric around zero.\n\n      var twa1 = (2 * i - 1) * ulen;\n\n      for (var jj = 1; jj <= nlegq; jj++) {\n        var j, t1;\n        if (ihalfq < jj) {\n          j = jj - ihalfq - 1;\n          t1 = (f2lf + (f21 * Math.log(twa1 + (xlegq[j] * ulen))))\n              - (((xlegq[j] * ulen) + twa1) * ff4);\n        } else {\n          j = jj - 1;\n          t1 = (f2lf + (f21 * Math.log(twa1 - (xlegq[j] * ulen))))\n              + (((xlegq[j] * ulen) - twa1) * ff4);\n        }\n\n        // if exp(t1) < 9e-14, then doesn't contribute to integral\n        var qsqz;\n        if (t1 >= eps1) {\n          if (ihalfq < jj) {\n            qsqz = q * Math.sqrt(((xlegq[j] * ulen) + twa1) * 0.5);\n          } else {\n            qsqz = q * Math.sqrt(((-(xlegq[j] * ulen)) + twa1) * 0.5);\n          }\n\n          // call wprob to find integral of range portion\n\n          var wprb = tukeyWprob(qsqz, rr, cc);\n          var rotsum = (wprb * alegq[j]) * Math.exp(t1);\n          otsum += rotsum;\n        }\n        // end legendre integral for interval i\n        // L200:\n      }\n\n      // if integral for interval i < 1e-14, then stop.\n      // However, in order to avoid small area under left tail,\n      // at least  1 / ulen  intervals are calculated.\n      if (i * ulen >= 1.0 && otsum <= eps2)\n        break;\n\n      // end of interval i\n      // L330:\n\n      ans += otsum;\n    }\n\n    if (otsum > eps2) { // not converged\n      throw new Error('tukey.cdf failed to converge');\n    }\n    if (ans > 1)\n      ans = 1;\n    return ans;\n  },\n\n  inv: function(p, nmeans, df) {\n    // Identical implementation as the R qtukey() function as of commit 68947\n    var rr = 1;\n    var cc = nmeans;\n\n    var eps = 0.0001;\n    var maxiter = 50;\n\n    // df must be > 1 ; there must be at least two values\n    if (df < 2 || rr < 1 || cc < 2) return NaN;\n\n    if (p < 0 || p > 1) return NaN;\n    if (p === 0) return 0;\n    if (p === 1) return Infinity;\n\n    // Initial value\n\n    var x0 = tukeyQinv(p, cc, df);\n\n    // Find prob(value < x0)\n\n    var valx0 = jStat.tukey.cdf(x0, nmeans, df) - p;\n\n    // Find the second iterate and prob(value < x1).\n    // If the first iterate has probability value\n    // exceeding p then second iterate is 1 less than\n    // first iterate; otherwise it is 1 greater.\n\n    var x1;\n    if (valx0 > 0.0)\n      x1 = Math.max(0.0, x0 - 1.0);\n    else\n      x1 = x0 + 1.0;\n    var valx1 = jStat.tukey.cdf(x1, nmeans, df) - p;\n\n    // Find new iterate\n\n    var ans;\n    for(var iter = 1; iter < maxiter; iter++) {\n      ans = x1 - ((valx1 * (x1 - x0)) / (valx1 - valx0));\n      valx0 = valx1;\n\n      // New iterate must be >= 0\n\n      x0 = x1;\n      if (ans < 0.0) {\n        ans = 0.0;\n        valx1 = -p;\n      }\n      // Find prob(value < new iterate)\n\n      valx1 = jStat.tukey.cdf(ans, nmeans, df) - p;\n      x1 = ans;\n\n      // If the difference between two successive\n      // iterates is less than eps, stop\n\n      var xabs = Math.abs(x1 - x0);\n      if (xabs < eps)\n        return ans;\n    }\n\n    throw new Error('tukey.inv failed to converge');\n  }\n});\n\n}(jStat, Math));\n/* Provides functions for the solution of linear system of equations, integration, extrapolation,\n * interpolation, eigenvalue problems, differential equations and PCA analysis. */\n\n(function(jStat, Math) {\n\nvar push = Array.prototype.push;\nvar isArray = jStat.utils.isArray;\n\nfunction isUsable(arg) {\n  return isArray(arg) || arg instanceof jStat;\n}\n\njStat.extend({\n\n  // add a vector/matrix to a vector/matrix or scalar\n  add: function add(arr, arg) {\n    // check if arg is a vector or scalar\n    if (isUsable(arg)) {\n      if (!isUsable(arg[0])) arg = [ arg ];\n      return jStat.map(arr, function(value, row, col) {\n        return value + arg[row][col];\n      });\n    }\n    return jStat.map(arr, function(value) { return value + arg; });\n  },\n\n  // subtract a vector or scalar from the vector\n  subtract: function subtract(arr, arg) {\n    // check if arg is a vector or scalar\n    if (isUsable(arg)) {\n      if (!isUsable(arg[0])) arg = [ arg ];\n      return jStat.map(arr, function(value, row, col) {\n        return value - arg[row][col] || 0;\n      });\n    }\n    return jStat.map(arr, function(value) { return value - arg; });\n  },\n\n  // matrix division\n  divide: function divide(arr, arg) {\n    if (isUsable(arg)) {\n      if (!isUsable(arg[0])) arg = [ arg ];\n      return jStat.multiply(arr, jStat.inv(arg));\n    }\n    return jStat.map(arr, function(value) { return value / arg; });\n  },\n\n  // matrix multiplication\n  multiply: function multiply(arr, arg) {\n    var row, col, nrescols, sum, nrow, ncol, res, rescols;\n    // eg: arr = 2 arg = 3 -> 6 for res[0][0] statement closure\n    if (arr.length === undefined && arg.length === undefined) {\n      return arr * arg;\n    }\n    nrow = arr.length,\n    ncol = arr[0].length,\n    res = jStat.zeros(nrow, nrescols = (isUsable(arg)) ? arg[0].length : ncol),\n    rescols = 0;\n    if (isUsable(arg)) {\n      for (; rescols < nrescols; rescols++) {\n        for (row = 0; row < nrow; row++) {\n          sum = 0;\n          for (col = 0; col < ncol; col++)\n          sum += arr[row][col] * arg[col][rescols];\n          res[row][rescols] = sum;\n        }\n      }\n      return (nrow === 1 && rescols === 1) ? res[0][0] : res;\n    }\n    return jStat.map(arr, function(value) { return value * arg; });\n  },\n\n  // outer([1,2,3],[4,5,6])\n  // ===\n  // [[1],[2],[3]] times [[4,5,6]]\n  // ->\n  // [[4,5,6],[8,10,12],[12,15,18]]\n  outer:function outer(A, B) {\n    return jStat.multiply(A.map(function(t){ return [t] }), [B]);\n  },\n\n\n  // Returns the dot product of two matricies\n  dot: function dot(arr, arg) {\n    if (!isUsable(arr[0])) arr = [ arr ];\n    if (!isUsable(arg[0])) arg = [ arg ];\n    // convert column to row vector\n    var left = (arr[0].length === 1 && arr.length !== 1) ? jStat.transpose(arr) : arr,\n    right = (arg[0].length === 1 && arg.length !== 1) ? jStat.transpose(arg) : arg,\n    res = [],\n    row = 0,\n    nrow = left.length,\n    ncol = left[0].length,\n    sum, col;\n    for (; row < nrow; row++) {\n      res[row] = [];\n      sum = 0;\n      for (col = 0; col < ncol; col++)\n      sum += left[row][col] * right[row][col];\n      res[row] = sum;\n    }\n    return (res.length === 1) ? res[0] : res;\n  },\n\n  // raise every element by a scalar\n  pow: function pow(arr, arg) {\n    return jStat.map(arr, function(value) { return Math.pow(value, arg); });\n  },\n\n  // exponentiate every element\n  exp: function exp(arr) {\n    return jStat.map(arr, function(value) { return Math.exp(value); });\n  },\n\n  // generate the natural log of every element\n  log: function exp(arr) {\n    return jStat.map(arr, function(value) { return Math.log(value); });\n  },\n\n  // generate the absolute values of the vector\n  abs: function abs(arr) {\n    return jStat.map(arr, function(value) { return Math.abs(value); });\n  },\n\n  // computes the p-norm of the vector\n  // In the case that a matrix is passed, uses the first row as the vector\n  norm: function norm(arr, p) {\n    var nnorm = 0,\n    i = 0;\n    // check the p-value of the norm, and set for most common case\n    if (isNaN(p)) p = 2;\n    // check if multi-dimensional array, and make vector correction\n    if (isUsable(arr[0])) arr = arr[0];\n    // vector norm\n    for (; i < arr.length; i++) {\n      nnorm += Math.pow(Math.abs(arr[i]), p);\n    }\n    return Math.pow(nnorm, 1 / p);\n  },\n\n  // computes the angle between two vectors in rads\n  // In case a matrix is passed, this uses the first row as the vector\n  angle: function angle(arr, arg) {\n    return Math.acos(jStat.dot(arr, arg) / (jStat.norm(arr) * jStat.norm(arg)));\n  },\n\n  // augment one matrix by another\n  // Note: this function returns a matrix, not a jStat object\n  aug: function aug(a, b) {\n    var newarr = [];\n    for (var i = 0; i < a.length; i++) {\n      newarr.push(a[i].slice());\n    }\n    for (var i = 0; i < newarr.length; i++) {\n      push.apply(newarr[i], b[i]);\n    }\n    return newarr;\n  },\n\n  // The inv() function calculates the inverse of a matrix\n  // Create the inverse by augmenting the matrix by the identity matrix of the\n  // appropriate size, and then use G-J elimination on the augmented matrix.\n  inv: function inv(a) {\n    var rows = a.length;\n    var cols = a[0].length;\n    var b = jStat.identity(rows, cols);\n    var c = jStat.gauss_jordan(a, b);\n    var result = [];\n    var i = 0;\n    var j;\n\n    //We need to copy the inverse portion to a new matrix to rid G-J artifacts\n    for (; i < rows; i++) {\n      result[i] = [];\n      for (j = cols; j < c[0].length; j++)\n        result[i][j - cols] = c[i][j];\n    }\n    return result;\n  },\n\n  // calculate the determinant of a matrix\n  det: function det(a) {\n    var alen = a.length,\n    alend = alen * 2,\n    vals = new Array(alend),\n    rowshift = alen - 1,\n    colshift = alend - 1,\n    mrow = rowshift - alen + 1,\n    mcol = colshift,\n    i = 0,\n    result = 0,\n    j;\n    // check for special 2x2 case\n    if (alen === 2) {\n      return a[0][0] * a[1][1] - a[0][1] * a[1][0];\n    }\n    for (; i < alend; i++) {\n      vals[i] = 1;\n    }\n    for (var i = 0; i < alen; i++) {\n      for (j = 0; j < alen; j++) {\n        vals[(mrow < 0) ? mrow + alen : mrow ] *= a[i][j];\n        vals[(mcol < alen) ? mcol + alen : mcol ] *= a[i][j];\n        mrow++;\n        mcol--;\n      }\n      mrow = --rowshift - alen + 1;\n      mcol = --colshift;\n    }\n    for (var i = 0; i < alen; i++) {\n      result += vals[i];\n    }\n    for (; i < alend; i++) {\n      result -= vals[i];\n    }\n    return result;\n  },\n\n  gauss_elimination: function gauss_elimination(a, b) {\n    var i = 0,\n    j = 0,\n    n = a.length,\n    m = a[0].length,\n    factor = 1,\n    sum = 0,\n    x = [],\n    maug, pivot, temp, k;\n    a = jStat.aug(a, b);\n    maug = a[0].length;\n    for(var i = 0; i < n; i++) {\n      pivot = a[i][i];\n      j = i;\n      for (k = i + 1; k < m; k++) {\n        if (pivot < Math.abs(a[k][i])) {\n          pivot = a[k][i];\n          j = k;\n        }\n      }\n      if (j != i) {\n        for(k = 0; k < maug; k++) {\n          temp = a[i][k];\n          a[i][k] = a[j][k];\n          a[j][k] = temp;\n        }\n      }\n      for (j = i + 1; j < n; j++) {\n        factor = a[j][i] / a[i][i];\n        for(k = i; k < maug; k++) {\n          a[j][k] = a[j][k] - factor * a[i][k];\n        }\n      }\n    }\n    for (var i = n - 1; i >= 0; i--) {\n      sum = 0;\n      for (j = i + 1; j<= n - 1; j++) {\n        sum = sum + x[j] * a[i][j];\n      }\n      x[i] =(a[i][maug - 1] - sum) / a[i][i];\n    }\n    return x;\n  },\n\n  gauss_jordan: function gauss_jordan(a, b) {\n    var m = jStat.aug(a, b),\n    h = m.length,\n    w = m[0].length;\n    var c = 0;\n    // find max pivot\n    for (var y = 0; y < h; y++) {\n      var maxrow = y;\n      for (var y2 = y+1; y2 < h; y2++) {\n        if (Math.abs(m[y2][y]) > Math.abs(m[maxrow][y]))\n          maxrow = y2;\n      }\n      var tmp = m[y];\n      m[y] = m[maxrow];\n      m[maxrow] = tmp\n      for (var y2 = y+1; y2 < h; y2++) {\n        c = m[y2][y] / m[y][y];\n        for (var x = y; x < w; x++) {\n          m[y2][x] -= m[y][x] * c;\n        }\n      }\n    }\n    // backsubstitute\n    for (var y = h-1; y >= 0; y--) {\n      c = m[y][y];\n      for (var y2 = 0; y2 < y; y2++) {\n        for (var x = w-1; x > y-1; x--) {\n          m[y2][x] -= m[y][x] * m[y2][y] / c;\n        }\n      }\n      m[y][y] /= c;\n      for (var x = h; x < w; x++) {\n        m[y][x] /= c;\n      }\n    }\n    return m;\n  },\n\n  // solve equation\n  // Ax=b\n  // A is upper triangular matrix\n  // A=[[1,2,3],[0,4,5],[0,6,7]]\n  // b=[1,2,3]\n  // triaUpSolve(A,b) // -> [2.666,0.1666,1.666]\n  // if you use matrix style\n  // A=[[1,2,3],[0,4,5],[0,6,7]]\n  // b=[[1],[2],[3]]\n  // will return [[2.666],[0.1666],[1.666]]\n  triaUpSolve: function triaUpSolve(A, b) {\n    var size = A[0].length;\n    var x = jStat.zeros(1, size)[0];\n    var parts;\n    var matrix_mode = false;\n\n    if (b[0].length != undefined) {\n      b = b.map(function(i){ return i[0] });\n      matrix_mode = true;\n    }\n\n    jStat.arange(size - 1, -1, -1).forEach(function(i) {\n      parts = jStat.arange(i + 1, size).map(function(j) {\n        return x[j] * A[i][j];\n      });\n      x[i] = (b[i] - jStat.sum(parts)) / A[i][i];\n    });\n\n    if (matrix_mode)\n      return x.map(function(i){ return [i] });\n    return x;\n  },\n\n  triaLowSolve: function triaLowSolve(A, b) {\n    // like to triaUpSolve but A is lower triangular matrix\n    var size = A[0].length;\n    var x = jStat.zeros(1, size)[0];\n    var parts;\n\n    var matrix_mode=false;\n    if (b[0].length != undefined) {\n      b = b.map(function(i){ return i[0] });\n      matrix_mode = true;\n    }\n\n    jStat.arange(size).forEach(function(i) {\n      parts = jStat.arange(i).map(function(j) {\n        return A[i][j] * x[j];\n      });\n      x[i] = (b[i] - jStat.sum(parts)) / A[i][i];\n    })\n\n    if (matrix_mode)\n      return x.map(function(i){ return [i] });\n    return x;\n  },\n\n\n  // A -> [L,U]\n  // A=LU\n  // L is lower triangular matrix\n  // U is upper triangular matrix\n  lu: function lu(A) {\n    var size = A.length;\n    //var L=jStat.diagonal(jStat.ones(1,size)[0]);\n    var L = jStat.identity(size);\n    var R = jStat.zeros(A.length, A[0].length);\n    var parts;\n    jStat.arange(size).forEach(function(t) {\n      R[0][t] = A[0][t];\n    });\n    jStat.arange(1, size).forEach(function(l) {\n      jStat.arange(l).forEach(function(i) {\n        parts = jStat.arange(i).map(function(jj) {\n          return L[l][jj] * R[jj][i];\n        });\n        L[l][i] = (A[l][i] - jStat.sum(parts)) / R[i][i];\n      });\n      jStat.arange(l, size).forEach(function(j) {\n        parts = jStat.arange(l).map(function(jj) {\n          return L[l][jj] * R[jj][j];\n        });\n        R[l][j] = A[i][j] - jStat.sum(parts);\n      });\n    });\n    return [L, R];\n  },\n\n  // A -> T\n  // A=TT'\n  // T is lower triangular matrix\n  cholesky: function cholesky(A) {\n    var size = A.length;\n    var T = jStat.zeros(A.length, A[0].length);\n    var parts;\n    jStat.arange(size).forEach(function(i) {\n      parts = jStat.arange(i).map(function(t) {\n        return Math.pow(T[i][t],2);\n      });\n      T[i][i] = Math.sqrt(A[i][i] - jStat.sum(parts));\n      jStat.arange(i + 1, size).forEach(function(j) {\n        parts = jStat.arange(i).map(function(t) {\n          return T[i][t] * T[j][t];\n        });\n        T[j][i] = (A[i][j] - jStat.sum(parts)) / T[i][i];\n      });\n    });\n    return T;\n  },\n\n\n  gauss_jacobi: function gauss_jacobi(a, b, x, r) {\n    var i = 0;\n    var j = 0;\n    var n = a.length;\n    var l = [];\n    var u = [];\n    var d = [];\n    var xv, c, h, xk;\n    for (; i < n; i++) {\n      l[i] = [];\n      u[i] = [];\n      d[i] = [];\n      for (j = 0; j < n; j++) {\n        if (i > j) {\n          l[i][j] = a[i][j];\n          u[i][j] = d[i][j] = 0;\n        } else if (i < j) {\n          u[i][j] = a[i][j];\n          l[i][j] = d[i][j] = 0;\n        } else {\n          d[i][j] = a[i][j];\n          l[i][j] = u[i][j] = 0;\n        }\n      }\n    }\n    h = jStat.multiply(jStat.multiply(jStat.inv(d), jStat.add(l, u)), -1);\n    c = jStat.multiply(jStat.inv(d), b);\n    xv = x;\n    xk = jStat.add(jStat.multiply(h, x), c);\n    i = 2;\n    while (Math.abs(jStat.norm(jStat.subtract(xk,xv))) > r) {\n      xv = xk;\n      xk = jStat.add(jStat.multiply(h, xv), c);\n      i++;\n    }\n    return xk;\n  },\n\n  gauss_seidel: function gauss_seidel(a, b, x, r) {\n    var i = 0;\n    var n = a.length;\n    var l = [];\n    var u = [];\n    var d = [];\n    var j, xv, c, h, xk;\n    for (; i < n; i++) {\n      l[i] = [];\n      u[i] = [];\n      d[i] = [];\n      for (j = 0; j < n; j++) {\n        if (i > j) {\n          l[i][j] = a[i][j];\n          u[i][j] = d[i][j] = 0;\n        } else if (i < j) {\n          u[i][j] = a[i][j];\n          l[i][j] = d[i][j] = 0;\n        } else {\n          d[i][j] = a[i][j];\n          l[i][j] = u[i][j] = 0;\n        }\n      }\n    }\n    h = jStat.multiply(jStat.multiply(jStat.inv(jStat.add(d, l)), u), -1);\n    c = jStat.multiply(jStat.inv(jStat.add(d, l)), b);\n    xv = x;\n    xk = jStat.add(jStat.multiply(h, x), c);\n    i = 2;\n    while (Math.abs(jStat.norm(jStat.subtract(xk, xv))) > r) {\n      xv = xk;\n      xk = jStat.add(jStat.multiply(h, xv), c);\n      i = i + 1;\n    }\n    return xk;\n  },\n\n  SOR: function SOR(a, b, x, r, w) {\n    var i = 0;\n    var n = a.length;\n    var l = [];\n    var u = [];\n    var d = [];\n    var j, xv, c, h, xk;\n    for (; i < n; i++) {\n      l[i] = [];\n      u[i] = [];\n      d[i] = [];\n      for (j = 0; j < n; j++) {\n        if (i > j) {\n          l[i][j] = a[i][j];\n          u[i][j] = d[i][j] = 0;\n        } else if (i < j) {\n          u[i][j] = a[i][j];\n          l[i][j] = d[i][j] = 0;\n        } else {\n          d[i][j] = a[i][j];\n          l[i][j] = u[i][j] = 0;\n        }\n      }\n    }\n    h = jStat.multiply(jStat.inv(jStat.add(d, jStat.multiply(l, w))),\n                       jStat.subtract(jStat.multiply(d, 1 - w),\n                                      jStat.multiply(u, w)));\n    c = jStat.multiply(jStat.multiply(jStat.inv(jStat.add(d,\n        jStat.multiply(l, w))), b), w);\n    xv = x;\n    xk = jStat.add(jStat.multiply(h, x), c);\n    i = 2;\n    while (Math.abs(jStat.norm(jStat.subtract(xk, xv))) > r) {\n      xv = xk;\n      xk = jStat.add(jStat.multiply(h, xv), c);\n      i++;\n    }\n    return xk;\n  },\n\n  householder: function householder(a) {\n    var m = a.length;\n    var n = a[0].length;\n    var i = 0;\n    var w = [];\n    var p = [];\n    var alpha, r, k, j, factor;\n    for (; i < m - 1; i++) {\n      alpha = 0;\n      for (j = i + 1; j < n; j++)\n      alpha += (a[j][i] * a[j][i]);\n      factor = (a[i + 1][i] > 0) ? -1 : 1;\n      alpha = factor * Math.sqrt(alpha);\n      r = Math.sqrt((((alpha * alpha) - a[i + 1][i] * alpha) / 2));\n      w = jStat.zeros(m, 1);\n      w[i + 1][0] = (a[i + 1][i] - alpha) / (2 * r);\n      for (k = i + 2; k < m; k++) w[k][0] = a[k][i] / (2 * r);\n      p = jStat.subtract(jStat.identity(m, n),\n          jStat.multiply(jStat.multiply(w, jStat.transpose(w)), 2));\n      a = jStat.multiply(p, jStat.multiply(a, p));\n    }\n    return a;\n  },\n\n  // A -> [Q,R]\n  // Q is orthogonal matrix\n  // R is upper triangular\n  QR: (function() {\n    // x -> Q\n    // find a orthogonal matrix Q st.\n    // Qx=y\n    // y is [||x||,0,0,...]\n\n    // quick ref\n    var sum   = jStat.sum;\n    var range = jStat.arange;\n\n    function get_Q1(x) {\n      var size = x.length;\n      var norm_x = jStat.norm(x, 2);\n      var e1 = jStat.zeros(1, size)[0];\n      e1[0] = 1;\n      var u = jStat.add(jStat.multiply(jStat.multiply(e1, norm_x), -1), x);\n      var norm_u = jStat.norm(u, 2);\n      var v = jStat.divide(u, norm_u);\n      var Q = jStat.subtract(jStat.identity(size),\n                             jStat.multiply(jStat.outer(v, v), 2));\n      return Q;\n    }\n\n    function qr(A) {\n      var size = A[0].length;\n      var QList = [];\n      jStat.arange(size).forEach(function(i) {\n        var x = jStat.slice(A, { row: { start: i }, col: i });\n        var Q = get_Q1(x);\n        var Qn = jStat.identity(A.length);\n        Qn = jStat.sliceAssign(Qn, { row: { start: i }, col: { start: i }}, Q);\n        A = jStat.multiply(Qn, A);\n        QList.push(Qn);\n      });\n      var Q = QList.reduce(function(x, y){ return jStat.multiply(x,y) });\n      var R = A;\n      return [Q, R];\n    }\n\n    function qr2(x) {\n      // quick impletation\n      // https://www.stat.wisc.edu/~larget/math496/qr.html\n\n      var n = x.length;\n      var p = x[0].length;\n\n      x = jStat.copy(x);\n      r = jStat.zeros(p, p);\n\n      var i,j,k;\n      for(j = 0; j < p; j++){\n        r[j][j] = Math.sqrt(sum(range(n).map(function(i){\n          return x[i][j] * x[i][j];\n        })));\n        for(i = 0; i < n; i++){\n          x[i][j] = x[i][j] / r[j][j];\n        }\n        for(k = j+1; k < p; k++){\n          r[j][k] = sum(range(n).map(function(i){\n            return x[i][j] * x[i][k];\n          }));\n          for(i = 0; i < n; i++){\n            x[i][k] = x[i][k] - x[i][j]*r[j][k];\n          }\n        }\n      }\n      return [x, r];\n    }\n\n    return qr2;\n  }()),\n\n  lstsq: (function(A, b) {\n    // solve least squard problem for Ax=b as QR decomposition way if b is\n    // [[b1],[b2],[b3]] form will return [[x1],[x2],[x3]] array form solution\n    // else b is [b1,b2,b3] form will return [x1,x2,x3] array form solution\n    function R_I(A) {\n      A = jStat.copy(A);\n      var size = A.length;\n      var I = jStat.identity(size);\n      jStat.arange(size - 1, -1, -1).forEach(function(i) {\n        jStat.sliceAssign(\n            I, { row: i }, jStat.divide(jStat.slice(I, { row: i }), A[i][i]));\n        jStat.sliceAssign(\n            A, { row: i }, jStat.divide(jStat.slice(A, { row: i }), A[i][i]));\n        jStat.arange(i).forEach(function(j) {\n          var c = jStat.multiply(A[j][i], -1);\n          var Aj = jStat.slice(A, { row: j });\n          var cAi = jStat.multiply(jStat.slice(A, { row: i }), c);\n          jStat.sliceAssign(A, { row: j }, jStat.add(Aj, cAi));\n          var Ij = jStat.slice(I, { row: j });\n          var cIi = jStat.multiply(jStat.slice(I, { row: i }), c);\n          jStat.sliceAssign(I, { row: j }, jStat.add(Ij, cIi));\n        })\n      });\n      return I;\n    }\n\n    function qr_solve(A, b){\n      var array_mode = false;\n      if (b[0].length === undefined) {\n        // [c1,c2,c3] mode\n        b = b.map(function(x){ return [x] });\n        array_mode = true;\n      }\n      var QR = jStat.QR(A);\n      var Q = QR[0];\n      var R = QR[1];\n      var attrs = A[0].length;\n      var Q1 = jStat.slice(Q,{col:{end:attrs}});\n      var R1 = jStat.slice(R,{row:{end:attrs}});\n      var RI = R_I(R1);\n\t  var Q2 = jStat.transpose(Q1);\n\n\t  if(Q2[0].length === undefined){\n\t\t  Q2 = [Q2]; // The confusing jStat.multifly implementation threat nature process again.\n\t  }\n\n      var x = jStat.multiply(jStat.multiply(RI, Q2), b);\n\n\t  if(x.length === undefined){\n\t\t  x = [[x]]; // The confusing jStat.multifly implementation threat nature process again.\n\t  }\n\n\n      if (array_mode)\n        return x.map(function(i){ return i[0] });\n      return x;\n    }\n\n    return qr_solve;\n  }()),\n\n  jacobi: function jacobi(a) {\n    var condition = 1;\n    var count = 0;\n    var n = a.length;\n    var e = jStat.identity(n, n);\n    var ev = [];\n    var b, i, j, p, q, maxim, theta, s;\n    // condition === 1 only if tolerance is not reached\n    while (condition === 1) {\n      count++;\n      maxim = a[0][1];\n      p = 0;\n      q = 1;\n      for (var i = 0; i < n; i++) {\n        for (j = 0; j < n; j++) {\n          if (i != j) {\n            if (maxim < Math.abs(a[i][j])) {\n              maxim = Math.abs(a[i][j]);\n              p = i;\n              q = j;\n            }\n          }\n        }\n      }\n      if (a[p][p] === a[q][q])\n        theta = (a[p][q] > 0) ? Math.PI / 4 : -Math.PI / 4;\n      else\n        theta = Math.atan(2 * a[p][q] / (a[p][p] - a[q][q])) / 2;\n      s = jStat.identity(n, n);\n      s[p][p] = Math.cos(theta);\n      s[p][q] = -Math.sin(theta);\n      s[q][p] = Math.sin(theta);\n      s[q][q] = Math.cos(theta);\n      // eigen vector matrix\n      e = jStat.multiply(e, s);\n      b = jStat.multiply(jStat.multiply(jStat.inv(s), a), s);\n      a = b;\n      condition = 0;\n      for (var i = 1; i < n; i++) {\n        for (j = 1; j < n; j++) {\n          if (i != j && Math.abs(a[i][j]) > 0.001) {\n            condition = 1;\n          }\n        }\n      }\n    }\n    for (var i = 0; i < n; i++) ev.push(a[i][i]);\n    //returns both the eigenvalue and eigenmatrix\n    return [e, ev];\n  },\n\n  rungekutta: function rungekutta(f, h, p, t_j, u_j, order) {\n    var k1, k2, u_j1, k3, k4;\n    if (order === 2) {\n      while (t_j <= p) {\n        k1 = h * f(t_j, u_j);\n        k2 = h * f(t_j + h, u_j + k1);\n        u_j1 = u_j + (k1 + k2) / 2;\n        u_j = u_j1;\n        t_j = t_j + h;\n      }\n    }\n    if (order === 4) {\n      while (t_j <= p) {\n        k1 = h * f(t_j, u_j);\n        k2 = h * f(t_j + h / 2, u_j + k1 / 2);\n        k3 = h * f(t_j + h / 2, u_j + k2 / 2);\n        k4 = h * f(t_j +h, u_j + k3);\n        u_j1 = u_j + (k1 + 2 * k2 + 2 * k3 + k4) / 6;\n        u_j = u_j1;\n        t_j = t_j + h;\n      }\n    }\n    return u_j;\n  },\n\n  romberg: function romberg(f, a, b, order) {\n    var i = 0;\n    var h = (b - a) / 2;\n    var x = [];\n    var h1 = [];\n    var g = [];\n    var m, a1, j, k, I, d;\n    while (i < order / 2) {\n      I = f(a);\n      for (j = a, k = 0; j <= b; j = j + h, k++) x[k] = j;\n      m = x.length;\n      for (j = 1; j < m - 1; j++) {\n        I += (((j % 2) !== 0) ? 4 : 2) * f(x[j]);\n      }\n      I = (h / 3) * (I + f(b));\n      g[i] = I;\n      h /= 2;\n      i++;\n    }\n    a1 = g.length;\n    m = 1;\n    while (a1 !== 1) {\n      for (j = 0; j < a1 - 1; j++)\n      h1[j] = ((Math.pow(4, m)) * g[j + 1] - g[j]) / (Math.pow(4, m) - 1);\n      a1 = h1.length;\n      g = h1;\n      h1 = [];\n      m++;\n    }\n    return g;\n  },\n\n  richardson: function richardson(X, f, x, h) {\n    function pos(X, x) {\n      var i = 0;\n      var n = X.length;\n      var p;\n      for (; i < n; i++)\n        if (X[i] === x) p = i;\n      return p;\n    }\n    var n = X.length,\n    h_min = Math.abs(x - X[pos(X, x) + 1]),\n    i = 0,\n    g = [],\n    h1 = [],\n    y1, y2, m, a, j;\n    while (h >= h_min) {\n      y1 = pos(X, x + h);\n      y2 = pos(X, x);\n      g[i] = (f[y1] - 2 * f[y2] + f[2 * y2 - y1]) / (h * h);\n      h /= 2;\n      i++;\n    }\n    a = g.length;\n    m = 1;\n    while (a != 1) {\n      for (j = 0; j < a - 1; j++)\n      h1[j] = ((Math.pow(4, m)) * g[j + 1] - g[j]) / (Math.pow(4, m) - 1);\n      a = h1.length;\n      g = h1;\n      h1 = [];\n      m++;\n    }\n    return g;\n  },\n\n  simpson: function simpson(f, a, b, n) {\n    var h = (b - a) / n;\n    var I = f(a);\n    var x = [];\n    var j = a;\n    var k = 0;\n    var i = 1;\n    var m;\n    for (; j <= b; j = j + h, k++)\n      x[k] = j;\n    m = x.length;\n    for (; i < m - 1; i++) {\n      I += ((i % 2 !== 0) ? 4 : 2) * f(x[i]);\n    }\n    return (h / 3) * (I + f(b));\n  },\n\n  hermite: function hermite(X, F, dF, value) {\n    var n = X.length;\n    var p = 0;\n    var i = 0;\n    var l = [];\n    var dl = [];\n    var A = [];\n    var B = [];\n    var j;\n    for (; i < n; i++) {\n      l[i] = 1;\n      for (j = 0; j < n; j++) {\n        if (i != j) l[i] *= (value - X[j]) / (X[i] - X[j]);\n      }\n      dl[i] = 0;\n      for (j = 0; j < n; j++) {\n        if (i != j) dl[i] += 1 / (X [i] - X[j]);\n      }\n      A[i] = (1 - 2 * (value - X[i]) * dl[i]) * (l[i] * l[i]);\n      B[i] = (value - X[i]) * (l[i] * l[i]);\n      p += (A[i] * F[i] + B[i] * dF[i]);\n    }\n    return p;\n  },\n\n  lagrange: function lagrange(X, F, value) {\n    var p = 0;\n    var i = 0;\n    var j, l;\n    var n = X.length;\n    for (; i < n; i++) {\n      l = F[i];\n      for (j = 0; j < n; j++) {\n        // calculating the lagrange polynomial L_i\n        if (i != j) l *= (value - X[j]) / (X[i] - X[j]);\n      }\n      // adding the lagrange polynomials found above\n      p += l;\n    }\n    return p;\n  },\n\n  cubic_spline: function cubic_spline(X, F, value) {\n    var n = X.length;\n    var i = 0, j;\n    var A = [];\n    var B = [];\n    var alpha = [];\n    var c = [];\n    var h = [];\n    var b = [];\n    var d = [];\n    for (; i < n - 1; i++)\n      h[i] = X[i + 1] - X[i];\n    alpha[0] = 0;\n    for (var i = 1; i < n - 1; i++) {\n      alpha[i] = (3 / h[i]) * (F[i + 1] - F[i]) -\n          (3 / h[i-1]) * (F[i] - F[i-1]);\n    }\n    for (var i = 1; i < n - 1; i++) {\n      A[i] = [];\n      B[i] = [];\n      A[i][i-1] = h[i-1];\n      A[i][i] = 2 * (h[i - 1] + h[i]);\n      A[i][i+1] = h[i];\n      B[i][0] = alpha[i];\n    }\n    c = jStat.multiply(jStat.inv(A), B);\n    for (j = 0; j < n - 1; j++) {\n      b[j] = (F[j + 1] - F[j]) / h[j] - h[j] * (c[j + 1][0] + 2 * c[j][0]) / 3;\n      d[j] = (c[j + 1][0] - c[j][0]) / (3 * h[j]);\n    }\n    for (j = 0; j < n; j++) {\n      if (X[j] > value) break;\n    }\n    j -= 1;\n    return F[j] + (value - X[j]) * b[j] + jStat.sq(value-X[j]) *\n        c[j] + (value - X[j]) * jStat.sq(value - X[j]) * d[j];\n  },\n\n  gauss_quadrature: function gauss_quadrature() {\n    throw new Error('gauss_quadrature not yet implemented');\n  },\n\n  PCA: function PCA(X) {\n    var m = X.length;\n    var n = X[0].length;\n    var flag = false;\n    var i = 0;\n    var j, temp1;\n    var u = [];\n    var D = [];\n    var result = [];\n    var temp2 = [];\n    var Y = [];\n    var Bt = [];\n    var B = [];\n    var C = [];\n    var V = [];\n    var Vt = [];\n    for (var i = 0; i < m; i++) {\n      u[i] = jStat.sum(X[i]) / n;\n    }\n    for (var i = 0; i < n; i++) {\n      B[i] = [];\n      for(j = 0; j < m; j++) {\n        B[i][j] = X[j][i] - u[j];\n      }\n    }\n    B = jStat.transpose(B);\n    for (var i = 0; i < m; i++) {\n      C[i] = [];\n      for (j = 0; j < m; j++) {\n        C[i][j] = (jStat.dot([B[i]], [B[j]])) / (n - 1);\n      }\n    }\n    result = jStat.jacobi(C);\n    V = result[0];\n    D = result[1];\n    Vt = jStat.transpose(V);\n    for (var i = 0; i < D.length; i++) {\n      for (j = i; j < D.length; j++) {\n        if(D[i] < D[j])  {\n          temp1 = D[i];\n          D[i] = D[j];\n          D[j] = temp1;\n          temp2 = Vt[i];\n          Vt[i] = Vt[j];\n          Vt[j] = temp2;\n        }\n      }\n    }\n    Bt = jStat.transpose(B);\n    for (var i = 0; i < m; i++) {\n      Y[i] = [];\n      for (j = 0; j < Bt.length; j++) {\n        Y[i][j] = jStat.dot([Vt[i]], [Bt[j]]);\n      }\n    }\n    return [X, D, Vt, Y];\n  }\n});\n\n// extend jStat.fn with methods that require one argument\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    jStat.fn[passfunc] = function(arg, func) {\n      var tmpthis = this;\n      // check for callback\n      if (func) {\n        setTimeout(function() {\n          func.call(tmpthis, jStat.fn[passfunc].call(tmpthis, arg));\n        }, 15);\n        return this;\n      }\n      if (typeof jStat[passfunc](this, arg) === 'number')\n        return jStat[passfunc](this, arg);\n      else\n        return jStat(jStat[passfunc](this, arg));\n    };\n  }(funcs[i]));\n}('add divide multiply subtract dot pow exp log abs norm angle'.split(' ')));\n\n}(jStat, Math));\n(function(jStat, Math) {\n\nvar slice = [].slice;\nvar isNumber = jStat.utils.isNumber;\nvar isArray = jStat.utils.isArray;\n\n// flag==true denotes use of sample standard deviation\n// Z Statistics\njStat.extend({\n  // 2 different parameter lists:\n  // (value, mean, sd)\n  // (value, array, flag)\n  zscore: function zscore() {\n    var args = slice.call(arguments);\n    if (isNumber(args[1])) {\n      return (args[0] - args[1]) / args[2];\n    }\n    return (args[0] - jStat.mean(args[1])) / jStat.stdev(args[1], args[2]);\n  },\n\n  // 3 different paramter lists:\n  // (value, mean, sd, sides)\n  // (zscore, sides)\n  // (value, array, sides, flag)\n  ztest: function ztest() {\n    var args = slice.call(arguments);\n    var z;\n    if (isArray(args[1])) {\n      // (value, array, sides, flag)\n      z = jStat.zscore(args[0],args[1],args[3]);\n      return (args[2] === 1) ?\n        (jStat.normal.cdf(-Math.abs(z), 0, 1)) :\n        (jStat.normal.cdf(-Math.abs(z), 0, 1)*2);\n    } else {\n      if (args.length > 2) {\n        // (value, mean, sd, sides)\n        z = jStat.zscore(args[0],args[1],args[2]);\n        return (args[3] === 1) ?\n          (jStat.normal.cdf(-Math.abs(z),0,1)) :\n          (jStat.normal.cdf(-Math.abs(z),0,1)* 2);\n      } else {\n        // (zscore, sides)\n        z = args[0];\n        return (args[1] === 1) ?\n          (jStat.normal.cdf(-Math.abs(z),0,1)) :\n          (jStat.normal.cdf(-Math.abs(z),0,1)*2);\n      }\n    }\n  }\n});\n\njStat.extend(jStat.fn, {\n  zscore: function zscore(value, flag) {\n    return (value - this.mean()) / this.stdev(flag);\n  },\n\n  ztest: function ztest(value, sides, flag) {\n    var zscore = Math.abs(this.zscore(value, flag));\n    return (sides === 1) ?\n      (jStat.normal.cdf(-zscore, 0, 1)) :\n      (jStat.normal.cdf(-zscore, 0, 1) * 2);\n  }\n});\n\n// T Statistics\njStat.extend({\n  // 2 parameter lists\n  // (value, mean, sd, n)\n  // (value, array)\n  tscore: function tscore() {\n    var args = slice.call(arguments);\n    return (args.length === 4) ?\n      ((args[0] - args[1]) / (args[2] / Math.sqrt(args[3]))) :\n      ((args[0] - jStat.mean(args[1])) /\n       (jStat.stdev(args[1], true) / Math.sqrt(args[1].length)));\n  },\n\n  // 3 different paramter lists:\n  // (value, mean, sd, n, sides)\n  // (tscore, n, sides)\n  // (value, array, sides)\n  ttest: function ttest() {\n    var args = slice.call(arguments);\n    var tscore;\n    if (args.length === 5) {\n      tscore = Math.abs(jStat.tscore(args[0], args[1], args[2], args[3]));\n      return (args[4] === 1) ?\n        (jStat.studentt.cdf(-tscore, args[3]-1)) :\n        (jStat.studentt.cdf(-tscore, args[3]-1)*2);\n    }\n    if (isNumber(args[1])) {\n      tscore = Math.abs(args[0])\n      return (args[2] == 1) ?\n        (jStat.studentt.cdf(-tscore, args[1]-1)) :\n        (jStat.studentt.cdf(-tscore, args[1]-1) * 2);\n    }\n    tscore = Math.abs(jStat.tscore(args[0], args[1]))\n    return (args[2] == 1) ?\n      (jStat.studentt.cdf(-tscore, args[1].length-1)) :\n      (jStat.studentt.cdf(-tscore, args[1].length-1) * 2);\n  }\n});\n\njStat.extend(jStat.fn, {\n  tscore: function tscore(value) {\n    return (value - this.mean()) / (this.stdev(true) / Math.sqrt(this.cols()));\n  },\n\n  ttest: function ttest(value, sides) {\n    return (sides === 1) ?\n      (1 - jStat.studentt.cdf(Math.abs(this.tscore(value)), this.cols()-1)) :\n      (jStat.studentt.cdf(-Math.abs(this.tscore(value)), this.cols()-1)*2);\n  }\n});\n\n// F Statistics\njStat.extend({\n  // Paramter list is as follows:\n  // (array1, array2, array3, ...)\n  // or it is an array of arrays\n  // array of arrays conversion\n  anovafscore: function anovafscore() {\n    var args = slice.call(arguments),\n    expVar, sample, sampMean, sampSampMean, tmpargs, unexpVar, i, j;\n    if (args.length === 1) {\n      tmpargs = new Array(args[0].length);\n      for (var i = 0; i < args[0].length; i++) {\n        tmpargs[i] = args[0][i];\n      }\n      args = tmpargs;\n    }\n    // 2 sample case\n    if (args.length === 2) {\n      return jStat.variance(args[0]) / jStat.variance(args[1]);\n    }\n    // Builds sample array\n    sample = new Array();\n    for (var i = 0; i < args.length; i++) {\n      sample = sample.concat(args[i]);\n    }\n    sampMean = jStat.mean(sample);\n    // Computes the explained variance\n    expVar = 0;\n    for (var i = 0; i < args.length; i++) {\n      expVar = expVar + args[i].length * Math.pow(jStat.mean(args[i]) - sampMean, 2);\n    }\n    expVar /= (args.length - 1);\n    // Computes unexplained variance\n    unexpVar = 0;\n    for (var i = 0; i < args.length; i++) {\n      sampSampMean = jStat.mean(args[i]);\n      for (j = 0; j < args[i].length; j++) {\n        unexpVar += Math.pow(args[i][j] - sampSampMean, 2);\n      }\n    }\n    unexpVar /= (sample.length - args.length);\n    return expVar / unexpVar;\n  },\n\n  // 2 different paramter setups\n  // (array1, array2, array3, ...)\n  // (anovafscore, df1, df2)\n  anovaftest: function anovaftest() {\n    var args = slice.call(arguments),\n    df1, df2, n, i;\n    if (isNumber(args[0])) {\n      return 1 - jStat.centralF.cdf(args[0], args[1], args[2]);\n    }\n    anovafscore = jStat.anovafscore(args);\n    df1 = args.length - 1;\n    n = 0;\n    for (var i = 0; i < args.length; i++) {\n      n = n + args[i].length;\n    }\n    df2 = n - df1 - 1;\n    return 1 - jStat.centralF.cdf(anovafscore, df1, df2);\n  },\n\n  ftest: function ftest(fscore, df1, df2) {\n    return 1 - jStat.centralF.cdf(fscore, df1, df2);\n  }\n});\n\njStat.extend(jStat.fn, {\n  anovafscore: function anovafscore() {\n    return jStat.anovafscore(this.toArray());\n  },\n\n  anovaftes: function anovaftes() {\n    var n = 0;\n    var i;\n    for (var i = 0; i < this.length; i++) {\n      n = n + this[i].length;\n    }\n    return jStat.ftest(this.anovafscore(), this.length - 1, n - this.length);\n  }\n});\n\n// Tukey's range test\njStat.extend({\n  // 2 parameter lists\n  // (mean1, mean2, n1, n2, sd)\n  // (array1, array2, sd)\n  qscore: function qscore() {\n    var args = slice.call(arguments);\n    var mean1, mean2, n1, n2, sd;\n    if (isNumber(args[0])) {\n        mean1 = args[0];\n        mean2 = args[1];\n        n1 = args[2];\n        n2 = args[3];\n        sd = args[4];\n    } else {\n        mean1 = jStat.mean(args[0]);\n        mean2 = jStat.mean(args[1]);\n        n1 = args[0].length;\n        n2 = args[1].length;\n        sd = args[2];\n    }\n    return Math.abs(mean1 - mean2) / (sd * Math.sqrt((1 / n1 + 1 / n2) / 2));\n  },\n\n  // 3 different parameter lists:\n  // (qscore, n, k)\n  // (mean1, mean2, n1, n2, sd, n, k)\n  // (array1, array2, sd, n, k)\n  qtest: function qtest() {\n    var args = slice.call(arguments);\n\n    var qscore;\n    if (args.length === 3) {\n      qscore = args[0];\n      args = args.slice(1);\n    } else if (args.length === 7) {\n      qscore = jStat.qscore(args[0], args[1], args[2], args[3], args[4]);\n      args = args.slice(5);\n    } else {\n      qscore = jStat.qscore(args[0], args[1], args[2]);\n      args = args.slice(3);\n    }\n\n    var n = args[0];\n    var k = args[1];\n\n    return 1 - jStat.tukey.cdf(qscore, k, n - k);\n  },\n\n  tukeyhsd: function tukeyhsd(arrays) {\n    var sd = jStat.pooledstdev(arrays);\n    var means = arrays.map(function (arr) {return jStat.mean(arr);});\n    var n = arrays.reduce(function (n, arr) {return n + arr.length;}, 0);\n\n    var results = [];\n    for (var i = 0; i < arrays.length; ++i) {\n        for (var j = i + 1; j < arrays.length; ++j) {\n            var p = jStat.qtest(means[i], means[j], arrays[i].length, arrays[j].length, sd, n, arrays.length);\n            results.push([[i, j], p]);\n        }\n    }\n\n    return results;\n  }\n});\n\n// Error Bounds\njStat.extend({\n  // 2 different parameter setups\n  // (value, alpha, sd, n)\n  // (value, alpha, array)\n  normalci: function normalci() {\n    var args = slice.call(arguments),\n    ans = new Array(2),\n    change;\n    if (args.length === 4) {\n      change = Math.abs(jStat.normal.inv(args[1] / 2, 0, 1) *\n                        args[2] / Math.sqrt(args[3]));\n    } else {\n      change = Math.abs(jStat.normal.inv(args[1] / 2, 0, 1) *\n                        jStat.stdev(args[2]) / Math.sqrt(args[2].length));\n    }\n    ans[0] = args[0] - change;\n    ans[1] = args[0] + change;\n    return ans;\n  },\n\n  // 2 different parameter setups\n  // (value, alpha, sd, n)\n  // (value, alpha, array)\n  tci: function tci() {\n    var args = slice.call(arguments),\n    ans = new Array(2),\n    change;\n    if (args.length === 4) {\n      change = Math.abs(jStat.studentt.inv(args[1] / 2, args[3] - 1) *\n                        args[2] / Math.sqrt(args[3]));\n    } else {\n      change = Math.abs(jStat.studentt.inv(args[1] / 2, args[2].length - 1) *\n                        jStat.stdev(args[2], true) / Math.sqrt(args[2].length));\n    }\n    ans[0] = args[0] - change;\n    ans[1] = args[0] + change;\n    return ans;\n  },\n\n  significant: function significant(pvalue, alpha) {\n    return pvalue < alpha;\n  }\n});\n\njStat.extend(jStat.fn, {\n  normalci: function normalci(value, alpha) {\n    return jStat.normalci(value, alpha, this.toArray());\n  },\n\n  tci: function tci(value, alpha) {\n    return jStat.tci(value, alpha, this.toArray());\n  }\n});\n\n// internal method for calculating the z-score for a difference of proportions test\nfunction differenceOfProportions(p1, n1, p2, n2) {\n  if (p1 > 1 || p2 > 1 || p1 <= 0 || p2 <= 0) {\n    throw new Error(\"Proportions should be greater than 0 and less than 1\")\n  }\n  var pooled = (p1 * n1 + p2 * n2) / (n1 + n2);\n  var se = Math.sqrt(pooled * (1 - pooled) * ((1/n1) + (1/n2)));\n  return (p1 - p2) / se;\n}\n\n// Difference of Proportions\njStat.extend(jStat.fn, {\n  oneSidedDifferenceOfProportions: function oneSidedDifferenceOfProportions(p1, n1, p2, n2) {\n    var z = differenceOfProportions(p1, n1, p2, n2);\n    return jStat.ztest(z, 1);\n  },\n\n  twoSidedDifferenceOfProportions: function twoSidedDifferenceOfProportions(p1, n1, p2, n2) {\n    var z = differenceOfProportions(p1, n1, p2, n2);\n    return jStat.ztest(z, 2);\n  }\n});\n\n}(jStat, Math));\njStat.models = (function(){\n\n  function sub_regress(endog, exog) {\n    return ols(endog, exog);\n  }\n\n  function sub_regress(exog) {\n    var var_count = exog[0].length;\n    var modelList = jStat.arange(var_count).map(function(endog_index) {\n      var exog_index =\n          jStat.arange(var_count).filter(function(i){return i!==endog_index});\n      return ols(jStat.col(exog, endog_index).map(function(x){ return x[0] }),\n                 jStat.col(exog, exog_index))\n    });\n    return modelList;\n  }\n\n  // do OLS model regress\n  // exog have include const columns ,it will not generate it .In fact, exog is\n  // \"design matrix\" look at\n  //https://en.wikipedia.org/wiki/Design_matrix\n  function ols(endog, exog) {\n    var nobs = endog.length;\n    var df_model = exog[0].length - 1;\n    var df_resid = nobs-df_model - 1;\n    var coef = jStat.lstsq(exog, endog);\n    var predict =\n        jStat.multiply(exog, coef.map(function(x) { return [x] }))\n            .map(function(p) { return p[0] });\n    var resid = jStat.subtract(endog, predict);\n    var ybar = jStat.mean(endog);\n    // constant cause problem\n    // var SST = jStat.sum(endog.map(function(y) {\n    //   return Math.pow(y-ybar,2);\n    // }));\n    var SSE = jStat.sum(predict.map(function(f) {\n      return Math.pow(f - ybar, 2);\n    }));\n    var SSR = jStat.sum(endog.map(function(y, i) {\n      return Math.pow(y - predict[i], 2);\n    }));\n    var SST = SSE + SSR;\n    var R2 = (SSE / SST);\n    return {\n        exog:exog,\n        endog:endog,\n        nobs:nobs,\n        df_model:df_model,\n        df_resid:df_resid,\n        coef:coef,\n        predict:predict,\n        resid:resid,\n        ybar:ybar,\n        SST:SST,\n        SSE:SSE,\n        SSR:SSR,\n        R2:R2\n    };\n  }\n\n  // H0: b_I=0\n  // H1: b_I!=0\n  function t_test(model) {\n    var subModelList = sub_regress(model.exog);\n    //var sigmaHat=jStat.stdev(model.resid);\n    var sigmaHat = Math.sqrt(model.SSR / (model.df_resid));\n    var seBetaHat = subModelList.map(function(mod) {\n      var SST = mod.SST;\n      var R2 = mod.R2;\n      return sigmaHat / Math.sqrt(SST * (1 - R2));\n    });\n    var tStatistic = model.coef.map(function(coef, i) {\n      return (coef - 0) / seBetaHat[i];\n    });\n    var pValue = tStatistic.map(function(t) {\n      var leftppf = jStat.studentt.cdf(t, model.df_resid);\n      return (leftppf > 0.5 ? 1 - leftppf : leftppf) * 2;\n    });\n    var c = jStat.studentt.inv(0.975, model.df_resid);\n    var interval95 = model.coef.map(function(coef, i) {\n      var d = c * seBetaHat[i];\n      return [coef - d, coef + d];\n    })\n    return {\n        se: seBetaHat,\n        t: tStatistic,\n        p: pValue,\n        sigmaHat: sigmaHat,\n        interval95: interval95\n    };\n  }\n\n  function F_test(model) {\n    var F_statistic =\n        (model.R2 / model.df_model) / ((1 - model.R2) / model.df_resid);\n    var fcdf = function(x, n1, n2) {\n      return jStat.beta.cdf(x / (n2 / n1 + x), n1 / 2, n2 / 2)\n    }\n    var pvalue = 1 - fcdf(F_statistic, model.df_model, model.df_resid);\n    return { F_statistic: F_statistic, pvalue: pvalue };\n  }\n\n  function ols_wrap(endog, exog) {\n    var model = ols(endog,exog);\n    var ttest = t_test(model);\n    var ftest = F_test(model);\n    // Provide the Wherry / Ezekiel / McNemar / Cohen Adjusted R^2\n    // Which matches the 'adjusted R^2' provided by R's lm package\n    var adjust_R2 =\n        1 - (1 - model.R2) * ((model.nobs - 1) / (model.df_resid));\n    model.t = ttest;\n    model.f = ftest;\n    model.adjust_R2 = adjust_R2;\n    return model;\n  }\n\n  return { ols: ols_wrap };\n})();\n  // Make it compatible with previous version.\n  jStat.jStat = jStat;\n\n  return jStat;\n});\n"],"sourceRoot":""}